# this file is generated by ci.ts, do not edit it manually

name: CI
permissions:
  contents: read
  deployments: write
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      stage:
        description: The stage to deploy to. Must correspond to a Doppler config in the os project (prd, stg, dev, dev_bob etc.).
        required: false
        type: string
jobs:
  variables:
    runs-on: ubuntu-latest
    steps:
      - id: get_env
        name: Get environment variables
        run: |-
          echo stage=${{ inputs.stage || 'prd' }} >> $GITHUB_OUTPUT
          echo release_name="v$(TZ=Europe/London date +%Y-%m-%d-%H-%M-%S)" >> $GITHUB_OUTPUT
    outputs:
      stage: ${{ steps.get_env.outputs.stage }}
      release_name: ${{ steps.get_env.outputs.release_name }}
  deploy:
    uses: ./.github/workflows/deploy.yml
    needs:
      - variables
    secrets: inherit
    with:
      stage: ${{ needs.variables.outputs.stage }}
  daytona-test:
    needs:
      - variables
      - deploy
    if: needs.variables.outputs.stage == 'prd'
    runs-on: ${{ github.repository_owner == 'iterate' && 'depot-ubuntu-24.04-arm-4' || 'ubuntu-24.04' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm
      - name: Install dependencies
        run: pnpm install
      - name: Install Doppler CLI
        uses: dopplerhq/cli-action@v2
      - name: Setup Doppler
        run: doppler setup --config prd --project os
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN }}
      - name: Install cloudflared
        run: |-
          # Detect architecture and download appropriate cloudflared binary
          ARCH=$(uname -m)
          if [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            CLOUDFLARED_ARCH="arm64"
          else
            CLOUDFLARED_ARCH="amd64"
          fi
          curl -L "https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-$CLOUDFLARED_ARCH" -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/
          cloudflared --version
      - name: Run Daytona Tests
        env:
          RUN_DAYTONA_TESTS: "true"
          DAYTONA_API_KEY: ${{ secrets.DAYTONA_API_KEY }}
          SANDBOX_ITERATE_REPO_REF: ${{ github.sha }}
        run: pnpm os snapshot:daytona:test
  release:
    needs:
      - variables
      - deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Write last release
        run: echo "LAST_RELEASE=$(git describe --tags --abbrev=0 || echo '')" >> $GITHUB_ENV
      - name: Write changelog
        run: |-
          add_to_changelog() {
            echo "$1" >> changelog.md
            echo "" >> changelog.md
          }

          if [ "$LAST_RELEASE" = "" ]; then
            LAST_RELEASE=$(git rev-parse HEAD~1)
            add_to_changelog "No previous release found - using HEAD~1 ($LAST_RELEASE)"
          else
            add_to_changelog "Last tagged release: [$LAST_RELEASE](${{ github.event.repository.html_url }}/releases/$LAST_RELEASE) ([compare link](${{ github.event.repository.html_url }}/compare/$LAST_RELEASE...${{ needs.variables.outputs.release_name }}))"
          fi

          write_git_changes() {
            glob=$1
            description=${2:-$glob}

            changes=$(git log $LAST_RELEASE..HEAD --oneline -- $glob | sed 's/^/- /g')

            if [ "$changes" != "" ]; then
              add_to_changelog "## $description"
              add_to_changelog "$changes"
            fi
          }

          write_git_changes '.' 'changes'

          add_to_changelog "Triggered by: @${{ github.actor }}"

          add_to_changelog "[Comparison with current main](${{ github.event.repository.html_url }}/compare/${{ needs.variables.outputs.release_name }}...main)"

          echo "echoing changes for debugging (notes are not published unless deploying to production):"
          cat changelog.md
      - if: needs.variables.outputs.stage == 'prd'
        name: prd_release
        id: prd_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ITERATE_BOT_GITHUB_TOKEN }}
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "fs" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/ci.ts.fs-bc7b36fe4d2924e49800d9b3dc4a325c-tsx-shim.cjs",
              "module.exports.load = () => import(\"fs\")",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function prd_release(
              {
                github,
                context,
              },
            ) {
              const {
                promises: fs,
              } = await require(
                ".github/ts-workflows/workflows/ci.ts.fs-bc7b36fe4d2924e49800d9b3dc4a325c-tsx-shim.cjs" /* <-- shimmed module of "fs" that actions/github-script can require */,
              ).load();

              await github.rest.repos.createRelease({
                ...context.repo,
                tag_name: "${{ needs.variables.outputs.release_name }}",
                name: "${{ needs.variables.outputs.release_name }}",

                body: [`stage: \${{ needs.variables.outputs.stage }}`, //
                "", await fs.readFile("changelog.md", "utf8")].join("\n"),
              });
            };

            return __handler(vars);
  slack_failure:
    needs:
      - variables
      - deploy
      - daytona-test
      - release
    if: always() && contains(needs.*.result, 'failure')
    runs-on: ubuntu-latest
    env:
      NEEDS: ${{ toJson(needs) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm
      - name: Install dependencies
        run: pnpm install
      - name: notify_slack_on_failure
        id: notify_slack_on_failure
        uses: actions/github-script@v7
        with:
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "../utils/slack.ts" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/ci.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs",
              "module.exports.load = () => require(\"tsx/esm/api\").tsImport(\"../utils/slack.ts\", __filename);",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function notify_slack_on_failure() {
              const {
                getSlackClient,
                slackChannelIds,
              } = await require(
                ".github/ts-workflows/workflows/ci.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs" /* <-- shimmed module of "../utils/slack.ts" that actions/github-script can require */,
              ).load();

              const slack = getSlackClient("${{ secrets.SLACK_CI_BOT_TOKEN }}");
              const needs = JSON.parse(process.env.NEEDS);

              const failedJobs = Object.entries(needs).filter((
                [_, {
                  result,
                }],
              ) => result === "failure").map(([name]) => name);

              const {
                release_name,
                ...outputs
              } = needs.variables?.outputs;

              const outputsString = new URLSearchParams(outputs).toString().replaceAll("&", ", ");
              let message = `ðŸš¨ ${failedJobs.join(", ")} failed on \${{ github.ref_name }}. ${outputsString}.`;
              message += " <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow Run>";

              await slack.chat.postMessage({
                channel: slackChannelIds["#error-pulse"],
                text: message,
              });
            };

            return __handler(vars);