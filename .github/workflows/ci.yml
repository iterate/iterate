# this file is generated by ci.ts, do not edit it manually

name: CI
permissions:
  contents: read
  deployments: write
on:
  push:
    branches:
      - main
      - mmkal/25/10/29/slackclientinworkflows
  workflow_dispatch:
    inputs:
      stage:
        description: The stage to deploy to. Must correspond to a Doppler config in the os project (prd, stg, dev, dev_bob etc.).
        default: prd
        required: true
        type: string
jobs:
  variables:
    runs-on: ubuntu-latest
    steps:
      - id: get_env
        name: Get environment variables
        run: |-
          echo stage=${{ inputs.stage || 'stg' }} >> $GITHUB_OUTPUT
          echo release_name="v$(TS=Europe/London date +%Y-%m-%d-%H-%M-%S)" >> $GITHUB_OUTPUT
    outputs:
      stage: ${{ steps.get_env.outputs.stage }}
      release_name: ${{ steps.get_env.outputs.release_name }}
  deploy:
    uses: ./.github/workflows/deploy.yml
    needs:
      - variables
    secrets: inherit
    with:
      stage: ${{ needs.variables.outputs.stage }}
  release:
    needs:
      - variables
      - deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Write last release
        run: echo "LAST_RELEASE=$(git describe --tags --abbrev=0 || echo '')" >> $GITHUB_ENV
      - name: Write changelog
        run: |-
          add_to_changelog() {
            echo "$1" >> changelog.md
            echo "" >> changelog.md
          }

          if [ "$LAST_RELEASE" = "" ]; then
            LAST_RELEASE=$(git rev-parse HEAD~1)
            add_to_changelog "No previous release found - using HEAD~1 ($LAST_RELEASE)"
          fi

          add_to_changelog "Last tagged release: [$LAST_RELEASE](${{ github.event.repository.html_url }}/releases/$LAST_RELEASE) ([compare link](${{ github.event.repository.html_url }}/compare/$LAST_RELEASE..${{ needs.variables.outputs.release_name }}))"

          write_git_changes() {
            glob=$1
            description=${2:-$glob}

            changes=$(git log $(git describe --tags --abbrev=0)..HEAD --oneline -- $glob | sed 's/^/- /g')

            if [ "$changes" != "" ]; then
              add_to_changelog "## $description"
              add_to_changelog "$changes"
            fi
          }

          write_git_changes apps/os 'apps/os changes'
          write_git_changes ':!apps/os' 'other changes'

          add_to_changelog "Triggered by: @${{ github.actor }}"

          add_to_changelog "[Comparison with current main](${{ github.event.repository.html_url }}/compare/${{ needs.variables.outputs.release_name }}...main)"

          echo "echoing changes for debugging (notes are not published unless deploying to production):"
          cat changelog.md
      - if: needs.variables.outputs.stage == 'prd'
        name: prd_release
        id: prd_release
        uses: actions/github-script@v7
        with:
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "fs" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/ci.ts.fs-bc7b36fe4d2924e49800d9b3dc4a325c-tsx-shim.cjs",
              "module.exports.load = () => import(\"fs\")",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function prd_release(
              {
                github,
                context,
              },
            ) {
              const {
                promises: fs,
              } = await require(
                ".github/ts-workflows/workflows/ci.ts.fs-bc7b36fe4d2924e49800d9b3dc4a325c-tsx-shim.cjs" /* <-- shimmed module of "fs" that actions/github-script can require */,
              ).load();

              await github.rest.repos.createRelease({
                ...context.repo,
                tag_name: "${{ needs.variables.outputs.release_name }}",
                name: "${{ needs.variables.outputs.release_name }}",

                body: [`stage: \${{ needs.variables.outputs.stage }}`, //
                "", await fs.readFile("changelog.md", "utf8")].join("\n"),
              });
            };

            return __handler(vars);
      - if: needs.variables.outputs.stage == 'stg'
        name: stg_release
        id: stg_release
        uses: actions/github-script@v7
        with:
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "fs" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/ci.ts.fs-bc7b36fe4d2924e49800d9b3dc4a325c-tsx-shim.cjs",
              "module.exports.load = () => import(\"fs\")",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function stg_release(
              {
                github,
                context,
              },
            ) {
              const {
                promises: fs,
              } = await require(
                ".github/ts-workflows/workflows/ci.ts.fs-bc7b36fe4d2924e49800d9b3dc4a325c-tsx-shim.cjs" /* <-- shimmed module of "fs" that actions/github-script can require */,
              ).load();

              await github.rest.repos.createCommitComment({
                ...context.repo,
                commit_sha: "${{ github.sha }}",

                body: [`stage: \${{ needs.variables.outputs.stage }}`, //
                "", await fs.readFile("changelog.md", "utf8")].join("\n"),
              });
            };

            return __handler(vars);
  e2e:
    if: needs.variables.outputs.stage == 'prd' || needs.variables.outputs.stage == 'stg'
    uses: ./.github/workflows/e2e.yml
    secrets: inherit
    needs:
      - variables
      - deploy
    with:
      worker_url: ${{ needs.deploy.outputs.worker_url || 'some_garbage' }}
      stage: ${{ needs.variables.outputs.stage }}
  slack_failure:
    needs:
      - variables
      - deploy
      - e2e
    if: always() && contains(needs.*.result, 'failure')
    runs-on: ubuntu-latest
    env:
      NEEDS: ${{ toJson(needs) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm
      - name: Install dependencies
        run: pnpm install
      - name: notify_slack_on_failure
        id: notify_slack_on_failure
        uses: actions/github-script@v7
        with:
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "../utils/slack.ts" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/ci.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs",
              "module.exports.load = () => require(\"tsx/esm/api\").tsImport(\"../utils/slack.ts\", __filename);",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function notify_slack_on_failure() {
              const {
                getSlackClient,
                slackChannelIds,
              } = await require(
                ".github/ts-workflows/workflows/ci.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs" /* <-- shimmed module of "../utils/slack.ts" that actions/github-script can require */,
              ).load();

              const slack = getSlackClient("${{ secrets.SLACK_CI_BOT_TOKEN }}");
              const needs = JSON.parse(process.env.NEEDS);

              const failedJobs = Object.entries(needs).filter((
                [_, {
                  result,
                }],
              ) => result === "failure").map(([name]) => name);

              await slack.chat.postMessage({
                channel: slackChannelIds["#error-pulse"],

                blocks: [{
                  type: "header",

                  text: {
                    type: "plain_text",
                    text: `ðŸš¨ CI Failed: ${failedJobs.join(", ")}. Variables: ${new URLSearchParams(needs.variables?.outputs)}`,
                  },
                }, {
                  type: "section",

                  fields: [{
                    type: "mrkdwn",
                    text: "*Repository:* ${{ github.repository }}",
                  }, {
                    type: "mrkdwn",
                    text: "*Branch:* ${{ github.ref_name }}",
                  }, {
                    type: "mrkdwn",
                    text: "*Workflow:* ${{ github.workflow }}",
                  }, {
                    type: "mrkdwn",
                    text: "*Run Number:* ${{ github.run_number }}",
                  }],
                }, {
                  type: "section",

                  text: {
                    type: "mrkdwn",
                    text: "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow Run>",
                  },
                }],
              });
            };

            return __handler(vars);