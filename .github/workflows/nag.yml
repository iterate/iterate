# this file is generated by nag.ts, do not edit it manually

name: Nag about PRs
on:
  schedule:
    - cron: "*/15 * * * *"
  push:
    branches:
      - "**/*nag*"
jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm
      - name: Install dependencies
        run: pnpm install
      - name: doit
        id: doit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ITERATE_BOT_GITHUB_TOKEN }}
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "../utils/slack.ts" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs",
              "module.exports.load = () => require(\"tsx/esm/api\").tsImport(\"../utils/slack.ts\", __filename);",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function doit(
              {
                github,
                context,
              },
            ) {
              const {
                data: openPRs,
              } = await github.rest.pulls.list({
                ...context.repo,
                state: "open",
              });

              console.log(`got ${openPRs.length} open PRs`);

              for (const pr of openPRs) {
                const {
                  data: rawReviews,
                } = await github.rest.pulls.listReviews({
                  ...context.repo,
                  pull_number: pr.number,
                });

                const {
                  data: rawComments,
                } = await github.rest.issues.listComments({
                  ...context.repo,
                  issue_number: pr.number,
                });

                const reviews = rawReviews.filter((r) => r.user?.type !== "Bot").sort((a, b) => (a.submitted_at || "").localeCompare(b.submitted_at || ""));
                const comments = rawComments.filter((c) => c.user?.type !== "Bot").sort((a, b) => a.created_at.localeCompare(b.created_at));
                console.log(pr.number, pr.title, reviews, comments);
                const approval = reviews.find((review) => review.state === "APPROVED");

                const lastNagTime = pr.body?.split("\n").flatMap((line) => {
                  const maybeParams = new URLSearchParams(line.split(" ").find((p) => p.includes("=")));
                  const found = maybeParams.get("last_nag_time");
                  return found ? [new Date(found)] : [];
                }).findLast(Boolean); // find last time with nag info, since we append every couple of days

                const nodeIds = comments.map((c) => c.node_id).filter(Boolean);

                const res = await github.graphql(`
                              query($ids: [ID!]!) {
                                nodes(ids: $ids) {
                                  ... on Node { id }
                                  ... on Minimizable {
                                    isMinimized
                                    minimizedReason
                                  }
                                }
                              }
                            `, {
                  ids: nodeIds,
                });

                const unresolvedComments = res.nodes?.filter((n) => !n?.isMinimized);
                const lastActive = [comments.at(-1)?.created_at, reviews.at(-1)?.submitted_at].filter(Boolean).map((d) => new Date(d)).sort((a, b) => a.getTime() - b.getTime()).at(-1) || new Date(pr.created_at);

                const when = (d) => {
                  if (!d)
                    return "never";

                  const msAgo = Date.now() - d.getTime();

                  if (msAgo < 1000)
                    return "just now";

                  if (msAgo < 60 * 1000)
                    return `${Math.round(msAgo / 1000)} seconds ago`;

                  if (msAgo < 60 * 60 * 1000)
                    return `${Math.round(msAgo / (60 * 1000))} minutes ago`;

                  if (msAgo < 24 * 60 * 60 * 1000)
                    return `${Math.round(msAgo / (60 * 60 * 1000))} hours ago`;

                  return d.toISOString();
                };

                const reasonsToNag = {
                  automerge: `${!!pr.auto_merge}: <-- automerge-status`,
                  approval: approval ? `false: approved already` : `true: not approved yet`,
                  unresolvedComments: `${unresolvedComments?.length === 0}: ${unresolvedComments?.length} unresolved comments`,
                  noActivityForAWhile: `${lastActive.getTime() < Date.now() - 60 * 60_000}: last active ${when(lastActive)}`,
                  noNagsIn2Days: `${(lastNagTime?.getTime() || 0) < Date.now() - 48 * 60 * 60000}: last nag time ${when(lastNagTime)}`,
                };

                const shouldNag = Object.values(reasonsToNag).every((v) => v.startsWith("true"));

                console.log(`PR #${pr.number}`, pr.title, pr.html_url, {
                  reasonsToNag,
                  shouldNag,
                });

                if (shouldNag) {
                  const {
                    getSlackClient,
                    slackChannelIds,
                    slackUsers,
                  } = await require(
                    ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs" /* <-- shimmed module of "../utils/slack.ts" that actions/github-script can require */,
                  ).load();

                  const slack = getSlackClient("${{ secrets.SLACK_CI_BOT_TOKEN }}");
                  const slackUser = slackUsers.find((u) => u.github.toLowerCase() === pr.user?.login?.toLowerCase());
                  const atMention = slackUser ? `<@${slackUser.id}>` : pr.user?.login;

                  const message = await slack.chat.postMessage({
                    channel: slackChannelIds["#building"],
                    text: `PR ${pr.number} <${pr.html_url}|${pr.title}> by ${atMention} is set to auto-merge, but needs review.`,
                  });

                  const nagInfo = {
                    last_nag_time: new Date().toISOString(),

                    ...(message.ts && {
                      nag_message_ts: message.ts,
                    }),
                  };

                  await github.rest.pulls.update({
                    ...context.repo,
                    pull_number: pr.number,

                    body: [//
                    pr.body, "\n", `${new URLSearchParams(nagInfo)}`].join("\n"),
                  });
                }

                // annoyingly "all comments must be resolved" in a ruleset doesn't let automerge happen for hidden comments, and cursor bugbot loves to hide comments
                const incorrectlyMinimizedComments = comments.filter((c) => {
                  const node = res.nodes?.find(
                    (n) => n?.id === c.node_id && n?.minimizedReason?.toLowerCase() !== "resolved",
                  );

                  return node?.isMinimized;
                });

                console.info(`Incorrectly minimized comments`, incorrectlyMinimizedComments);

                for (const comment of incorrectlyMinimizedComments) {
                  console.info(`comment ${comment.html_url} needs to be re-minimized as RESOLVED`);

                  await github.graphql(`
                                    mutation($id: ID!) {
                                    minimizeComment(input: { subjectId: $id, classifier: RESOLVED }) {
                                        minimizedComment { id }
                                    }
                                    }
                                `, {
                    id: comment.node_id,
                  });

                  console.info(`Re-minimized as RESOLVED: ${comment.node_id} on PR #${pr.number}`);
                }
              }
            };

            return __handler(vars);