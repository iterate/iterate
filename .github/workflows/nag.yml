# this file is generated by nag.ts, do not edit it manually

name: Nag about PRs
on:
  schedule:
    - cron: "*/15 * * * *"
  push:
    branches:
      - "**/*nag*"
      - "*nag*"
  pull_request:
    types:
      - closed
      - auto_merge_enabled
jobs:
  run:
    if: "false"
    concurrency:
      group: global-nag-concurrency-group
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm
      - name: Install dependencies
        run: pnpm install
      - name: doit
        id: doit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ITERATE_BOT_GITHUB_TOKEN }}
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "../utils/github-script.ts" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/nag.ts.utilsgithubscriptts-65073544fd07df03882caac199eb89dc-tsx-shim.cjs",
              "module.exports.load = () => require(\"tsx/esm/api\").tsImport(\"../utils/github-script.ts\", __filename);",
            );

            // write a shimmed module of "../utils/slack.ts" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs",
              "module.exports.load = () => require(\"tsx/esm/api\").tsImport(\"../utils/slack.ts\", __filename);",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function doit(
              {
                github,
                context: _context,
              },
            ) {
              // todo: consider contributing a union like this to jlarky/gha-ts?





              const context = _context;

              console.log(`context`, JSON.stringify(context, null, 2));
              const isTest = context.eventName === "push" && context.actor === "mmkal";

              const {
                prState,
              } = await require(
                ".github/ts-workflows/workflows/nag.ts.utilsgithubscriptts-65073544fd07df03882caac199eb89dc-tsx-shim.cjs" /* <-- shimmed module of "../utils/github-script.ts" that actions/github-script can require */,
              ).load();

              if (context.eventName === "pull_request" && context.payload.action === "closed") {
                const state = prState(context.payload.pull_request?.body || "", "nag_info");
                const nags = state.read().nags?.filter((n) => n.message_ts) || [];

                for (const nag of nags) {
                  const {
                    getSlackClient,
                    slackChannelIds,
                  } = await require(
                    ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs" /* <-- shimmed module of "../utils/slack.ts" that actions/github-script can require */,
                  ).load();

                  const slack = getSlackClient("${{ secrets.SLACK_CI_BOT_TOKEN }}");
                  const reaction = context.payload.pull_request?.merged ? "merged" : "x";

                  await slack.reactions.add({
                    channel: nag.channel || slackChannelIds["#building"],
                    timestamp: nag.message_ts,
                    name: reaction,
                  });
                }

                return;
              }

              const {
                data: openPRs,
              } = await github.rest.pulls.list({
                ...context.repo,
                state: "open",
              });

              console.log(`got ${openPRs.length} open PRs`);

              for (const pr of openPRs) {
                const {
                  data: rawReviews,
                } = await github.rest.pulls.listReviews({
                  ...context.repo,
                  pull_number: pr.number,
                });

                const {
                  data: rawComments,
                } = await github.rest.issues.listComments({
                  ...context.repo,
                  issue_number: pr.number,
                });

                const reviews = rawReviews.filter((r) => r.user?.type !== "Bot").sort((a, b) => (a.submitted_at || "").localeCompare(b.submitted_at || ""));
                const comments = rawComments.filter((c) => c.user?.type !== "Bot").sort((a, b) => a.created_at.localeCompare(b.created_at));
                console.log(pr.number, pr.title, reviews, comments);
                const approval = reviews.find((review) => review.state === "APPROVED");
                const state = prState(pr.body || "", "nag_info");
                const nodeIds = comments.map((c) => c.node_id).filter(Boolean);

                const res = await github.graphql(`
                              query($ids: [ID!]!) {
                                nodes(ids: $ids) {
                                  ... on Node { id }
                                  ... on Minimizable {
                                    isMinimized
                                    minimizedReason
                                  }
                                }
                              }
                            `, {
                  ids: nodeIds,
                });

                const unresolvedComments = res.nodes?.filter((n) => !n?.isMinimized);
                const lastActive = [comments.at(-1)?.created_at, reviews.at(-1)?.submitted_at].filter(Boolean).map((d) => new Date(d)).sort((a, b) => a.getTime() - b.getTime()).at(-1) || new Date(pr.created_at);

                const timeAgo = (d) => {
                  const ms = Date.now() - new Date(d).getTime();

                  const props = {
                    ms: ms,
                    seconds: ms / 1000,
                    minutes: ms / (60 * 1000),
                    hours: ms / (60 * 60 * 1000),
                    days: ms / (24 * 60 * 60 * 1000),
                    weeks: ms / (7 * 24 * 60 * 60 * 1000),
                    years: ms / (365.25 * 24 * 60 * 60 * 1000),
                  };

                  const format = (unit) => {
                    const int = Math.floor(props[unit]);
                    return `${int} ${unit}${int === 1 ? "" : "s"} ago`;
                  };

                  const mostUseful = Object.entries(props).findLast(([_, value]) => value >= 1);

                  return {
                    ...props,
                    format,
                    pretty: format(mostUseful?.[0]),
                  };
                };

                const when = (d) => {
                  if (!d)
                    return "never";

                  return timeAgo(d).pretty;
                };

                const realWorkingHours = (now) => {
                  const [hour, day] = [now.getHours(), now.getDay()];
                  return hour >= 9 && hour < 18 && day !== 0 && day !== 6;
                };

                const testWorkingHours = () => {
                  return true;
                };

                const workingHours = isTest ? testWorkingHours : realWorkingHours;
                const lastNagTime = state.read().nags?.at(-1)?.time;

                const reasonsToNag = {
                  automerge: `${!!pr.auto_merge}: <-- automerge-status`,
                  approval: approval ? `false: approved already` : `true: not approved yet`,
                  unresolvedComments: `${unresolvedComments?.length === 0}: ${unresolvedComments?.length} unresolved comments`,
                  noActivityForAWhile: `${timeAgo(lastActive).minutes > 60}: last active ${when(lastActive)}`,
                  noNagForAWhile: `${timeAgo(lastNagTime || 0).hours > 2}: last nag ${when(lastNagTime)}`,
                  workingHours: `${workingHours(new Date())}: is working hours: ${workingHours.toString().match(/return (.*?);/)?.[1]}`,
                };

                if (context.eventName === "pull_request" && context.payload.action === "auto_merge_enabled" && pr.number === context.payload.pull_request?.number) {
                  delete reasonsToNag.noActivityForAWhile; // automerge was just enabled, let's assume the "recent activity" is the author enabling automerge
                }

                const shouldNag = Object.values(reasonsToNag).every((v) => v.startsWith("true"));

                console.log(`PR #${pr.number}`, pr.title, pr.html_url, {
                  reasonsToNag,
                  shouldNag,
                });

                const {
                  getSlackClient,
                  slackChannelIds,
                  slackUsers,
                } = await require(
                  ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs" /* <-- shimmed module of "../utils/slack.ts" that actions/github-script can require */,
                ).load();

                const slack = getSlackClient("${{ secrets.SLACK_CI_BOT_TOKEN }}");
                const slackUser = slackUsers.find((u) => u.github.toLowerCase() === pr.user?.login?.toLowerCase());
                const authorMention = slackUser ? `<@${slackUser.id}>` : pr.user?.login;

                const nagOrGiveUp = async () => {
                  const newNag = {
                    time: new Date().toISOString(),
                    channel: isTest ? slackChannelIds["#misha-test"] : slackChannelIds["#building"],
                  };

                  const lastNag = state.read().nags?.at(-1);

                  if (lastNag?.followup_message_ts) {
                    console.log(`Followup message already exists, giving up.`);
                    return;
                  }

                  const postMessage = (params) => {
                    return slack.chat.postMessage({
                      channel: newNag.channel,
                      ...params,

                      ...(isTest && {
                        text: params.text.replaceAll("<@U", "<...U"),
                      }),
                    });
                  };

                  if (lastNag?.message_ts) {
                    const othersMentions = slackUsers.filter((u) => u.github.toLowerCase() !== pr.user?.login?.toLowerCase()).filter((u) => new Date(u.oooUntil || 0).getTime() < Date.now()).map((u) => `<@${u.id}>`).join(" ");

                    const followup = await postMessage({
                      thread_ts: lastNag.message_ts,
                      text: `C'mon ${othersMentions}, poor ${authorMention} is waiting for your review on <${pr.html_url}|#${pr.number} ${pr.title}>`,
                    });

                    if (followup.ts) {
                      newNag.followup_message_ts = followup.ts;
                    }
                  } else {
                    const message = await postMessage({
                      text: `<${pr.html_url}|#${pr.number} ${pr.title}> by ${authorMention} is set to auto-merge, but needs review.`,
                    });

                    if (message.ts) {
                      newNag.message_ts = message.ts;
                    }
                  }

                  await github.rest.pulls.update({
                    ...context.repo,
                    pull_number: pr.number,

                    body: state.write({
                      nags: [// break
                      ...(state.read().nags || []), newNag],
                    }),
                  });
                };

                if (shouldNag) {
                  await nagOrGiveUp();
                }

                // annoyingly "all comments must be resolved" in a ruleset doesn't let automerge happen for hidden comments, and cursor bugbot loves to hide comments
                const incorrectlyMinimizedComments = comments.filter((c) => {
                  const node = res.nodes?.find(
                    (n) => n?.id === c.node_id && n?.minimizedReason?.toLowerCase() !== "resolved",
                  );

                  return node?.isMinimized;
                });

                console.info(`Incorrectly minimized comments`, incorrectlyMinimizedComments);

                for (const comment of incorrectlyMinimizedComments) {
                  console.info(`comment ${comment.html_url} needs to be re-minimized as RESOLVED`);
                  const dedent = String;

                  await github.graphql(dedent`
                                mutation($id: ID!) {
                                  minimizeComment(input: { subjectId: $id, classifier: RESOLVED }) {
                                      minimizedComment { id }
                                  }
                                }
                              `, {
                    id: comment.node_id,
                  });

                  console.info(`Re-minimized as RESOLVED: ${comment.node_id} on PR #${pr.number}`);
                }
              }
            };

            return __handler(vars);