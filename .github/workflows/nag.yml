# this file is generated by nag.ts, do not edit it manually

name: Nag about PRs
on:
  schedule:
    - cron: "*/15 * * * *"
  push:
    paths:
      - .github/workflows/nag.yml
jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24
          cache: pnpm
      - name: Install dependencies
        run: pnpm install
      - name: doit
        id: doit
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ITERATE_BOT_GITHUB_TOKEN }}
          script: |-
            github.log = {
              ...console,
              debug: () => {},
            };

            // write a shimmed module of "../utils/slack.ts" that actions/github-script can require (see https://github.com/actions/github-script?tab=readme-ov-file#this-action)
            require("fs").writeFileSync(
              ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs",
              "module.exports.load = () => require(\"tsx/esm/api\").tsImport(\"../utils/slack.ts\", __filename);",
            );

            const vars = {
              github,
              context,
              core,
              glob,
              io,
              require,
            };

            const __handler = async function doit(
              {
                github,
                context,
              },
            ) {
              const {
                data: openPRs,
              } = await github.rest.pulls.list({
                ...context.repo,
                state: "open",
              });

              console.log(`got ${openPRs.length} open PRs`);

              for (const pr of openPRs) {
                const {
                  data: rawReviews,
                } = await github.rest.pulls.listReviews({
                  ...context.repo,
                  pull_number: pr.number,
                });

                const {
                  data: rawComments,
                } = await github.rest.issues.listComments({
                  ...context.repo,
                  issue_number: pr.number,
                });

                const reviews = rawReviews.filter((r) => r.user?.type !== "Bot").sort((a, b) => (a.submitted_at || "").localeCompare(b.submitted_at || ""));
                const comments = rawComments.filter((c) => c.user?.type !== "Bot").sort((a, b) => a.created_at.localeCompare(b.created_at));
                console.log(pr.number, pr.title, reviews, comments);
                const approval = reviews.find((review) => review.state === "APPROVED");

                const oldNagInfo = pr.body?.split("\n").flatMap((line) => {
                  const maybeParams = new URLSearchParams(line.split(" ").find((p) => p.includes("=")));
                  const found = maybeParams.get("last_nag_time");
                  return found ? [maybeParams] : [];
                }).findLast(Boolean); // find nag info, since we append every couple of days

                const nodeIds = comments.map((c) => c.node_id).filter(Boolean);

                const res = await github.graphql(`
                              query($ids: [ID!]!) {
                                nodes(ids: $ids) {
                                  ... on Node { id }
                                  ... on Minimizable {
                                    isMinimized
                                    minimizedReason
                                  }
                                }
                              }
                            `, {
                  ids: nodeIds,
                });

                const unresolvedComments = res.nodes?.filter((n) => !n?.isMinimized);
                const lastActive = [comments.at(-1)?.created_at, reviews.at(-1)?.submitted_at].filter(Boolean).map((d) => new Date(d)).sort((a, b) => a.getTime() - b.getTime()).at(-1) || new Date(pr.created_at);

                const timeAgo = (d) => {
                  const ms = Date.now() - new Date(d).getTime();

                  const props = {
                    ms: ms,
                    seconds: ms / 1000,
                    minutes: ms / (60 * 1000),
                    hours: ms / (60 * 60 * 1000),
                    days: ms / (24 * 60 * 60 * 1000),
                    weeks: ms / (7 * 24 * 60 * 60 * 1000),
                    years: ms / (365.25 * 24 * 60 * 60 * 1000),
                  };

                  const format = (unit) => {
                    const int = Math.floor(props[unit]);
                    return `${int} ${unit}${int === 1 ? "" : "s"} ago`;
                  };

                  const mostUseful = Object.entries(props).findLast(([_, value]) => value >= 1);

                  return {
                    ...props,
                    format,
                    pretty: format(mostUseful?.[0]),
                  };
                };

                const when = (d) => {
                  if (!d)
                    return "never";

                  return timeAgo(d).pretty;
                };

                const workingHours = (now) => {
                  const [hour, day] = [now.getHours(), now.getDay()];
                  return hour >= 9 && hour < 18 && day !== 0 && day !== 6;
                };

                const lastNagTime = oldNagInfo?.get("last_nag_time");

                const reasonsToNag = {
                  automerge: `${!!pr.auto_merge}: <-- automerge-status`,
                  approval: approval ? `false: approved already` : `true: not approved yet`,
                  unresolvedComments: `${unresolvedComments?.length === 0}: ${unresolvedComments?.length} unresolved comments`,
                  noActivityForAWhile: `${timeAgo(lastActive).minutes > 60}: last active ${when(lastActive)}`,
                  noNagForAWhile: `${timeAgo(lastNagTime || 0).hours > 2}: last nag ${when(lastNagTime)}`,
                  activitySinceLastNag: `${lastActive > new Date(lastNagTime || 0)}: there was activity since last nag`,
                  workingHours: `${workingHours(new Date())}: is working hours: ${workingHours.toString().match(/return (.*?);/)?.[1]}`,
                };

                const shouldNag = Object.values(reasonsToNag).every((v) => v.startsWith("true"));

                console.log(`PR #${pr.number}`, pr.title, pr.html_url, {
                  reasonsToNag,
                  shouldNag,
                });

                const nagOrGiveUp = async () => {
                  const newNagInfo = {
                    last_nag_time: new Date().toISOString(),
                  };

                  const {
                    getSlackClient,
                    slackChannelIds,
                    slackUsers,
                  } = await require(
                    ".github/ts-workflows/workflows/nag.ts.utilsslackts-64e60416ee9563c2f22509a2a7a4ac68-tsx-shim.cjs" /* <-- shimmed module of "../utils/slack.ts" that actions/github-script can require */,
                  ).load();

                  const slack = getSlackClient("${{ secrets.SLACK_CI_BOT_TOKEN }}");
                  const slackUser = slackUsers.find((u) => u.github.toLowerCase() === pr.user?.login?.toLowerCase());
                  const authorMention = slackUser ? `<@${slackUser.id}>` : pr.user?.login;
                  const threadTs = oldNagInfo?.get("nag_message_ts");
                  const followupTs = oldNagInfo?.get("followup_message_ts");

                  if (threadTs) {
                    if (followupTs) {
                      console.log(`Followup message already exists, giving up.`);
                      return;
                    }

                    const othersMentions = slackUsers.filter((u) => u.github.toLowerCase() !== pr.user?.login?.toLowerCase()).filter((u) => new Date(u.oooUntil || 0).getTime() < Date.now()).map((u) => `<@${u.id}>`).join(" ");

                    const followup = await slack.chat.postMessage({
                      channel: slackChannelIds["#building"],
                      thread_ts: threadTs,
                      text: `C'mon ${othersMentions}, poor ${authorMention} is waiting for your review on <${pr.html_url}|#${pr.number} ${pr.title}>`,
                    });

                    if (followup.ts) {
                      newNagInfo.followup_message_ts = followup.ts;
                    }
                  } else {
                    const message = await slack.chat.postMessage({
                      channel: slackChannelIds["#building"],
                      text: `<${pr.html_url}|#${pr.number} ${pr.title}> by ${authorMention} is set to auto-merge, but needs review.`,
                    });

                    if (message.ts) {
                      newNagInfo.nag_message_ts = message.ts;
                    }
                  }

                  await github.rest.pulls.update({
                    ...context.repo,
                    pull_number: pr.number,

                    body: [//
                    pr.body, `${new URLSearchParams(newNagInfo)}`].join("\n"),
                  });
                };

                if (shouldNag) {
                  await nagOrGiveUp();
                }

                // annoyingly "all comments must be resolved" in a ruleset doesn't let automerge happen for hidden comments, and cursor bugbot loves to hide comments
                const incorrectlyMinimizedComments = comments.filter((c) => {
                  const node = res.nodes?.find(
                    (n) => n?.id === c.node_id && n?.minimizedReason?.toLowerCase() !== "resolved",
                  );

                  return node?.isMinimized;
                });

                console.info(`Incorrectly minimized comments`, incorrectlyMinimizedComments);

                for (const comment of incorrectlyMinimizedComments) {
                  console.info(`comment ${comment.html_url} needs to be re-minimized as RESOLVED`);

                  await github.graphql(`
                                    mutation($id: ID!) {
                                    minimizeComment(input: { subjectId: $id, classifier: RESOLVED }) {
                                        minimizedComment { id }
                                    }
                                    }
                                `, {
                    id: comment.node_id,
                  });

                  console.info(`Re-minimized as RESOLVED: ${comment.node_id} on PR #${pr.number}`);
                }
              }
            };

            return __handler(vars);