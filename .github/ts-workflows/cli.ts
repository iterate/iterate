import * as fs from "node:fs/promises";
import * as path from "node:path";
import assert from "node:assert";
import { z } from "zod";
import { createCli } from "trpc-cli";
import { type Workflow, type Step } from "@jlarky/gha-ts/workflow-types";
import * as YAML from "yaml";
import { initTRPC } from "@trpc/server";
import type { GithubScriptHandler, GitHubScriptVariables } from "./utils/github-script.ts";

const t = initTRPC.create();

const workflowsProcedure = t.procedure
  .input(
    z.object({
      force: z
        .string()
        .array()
        .default([])
        .describe(
          "If set, these workflows will always be regenerated, even if they are up to date. This can be used to forcefully update formatting etc.",
        ),
      dryRun: z.boolean().default(false),
    }),
  )
  .use(async ({ next, input }) => {
    const tsWorkflowsDir = path.join(import.meta.dirname, "workflows");
    const yamlWorkflowsDir = path.join(import.meta.dirname, "../workflows");
    const tsWorkflowFileNames = await fs.readdir(tsWorkflowsDir);
    const yamlWorkflowFileNames = await fs.readdir(yamlWorkflowsDir);

    const tsWorkflowsList = await Promise.all(
      tsWorkflowFileNames.map(async (filename) => {
        const workflowModule = await import(path.join(tsWorkflowsDir, filename)).catch((e) => {
          console.error(`Error importing ${filename}:`, e);
          return { default: {} };
        });

        const workflow = workflowModule.default as Workflow;
        if (!workflow) throw new Error(`Workflow ${filename} is missing a default export`);
        let yaml = YAML.stringify(workflow, { lineWidth: 0, aliasDuplicateObjects: false });
        yaml = `# this file is generated by ${filename}, do not edit it manually\n\n${yaml}`;
        return { filename, name: path.parse(filename).name, yaml, workflow };
      }),
    );
    const yamlWorkflowsList = await Promise.all(
      yamlWorkflowFileNames.map(async (filename) => {
        const yaml = await fs.readFile(path.join(yamlWorkflowsDir, filename), "utf8");
        const workflow = YAML.parse(yaml) as Workflow;
        return { filename, name: path.parse(filename).name, yaml, workflow };
      }),
    );
    const tsWorkflows = Object.fromEntries(
      tsWorkflowsList.filter((w) => w.workflow.jobs).map((w) => [w.name, w]),
    );
    const yamlWorkflows = Object.fromEntries(
      yamlWorkflowsList.filter((w) => w.workflow.jobs).map((w) => [w.name, w]),
    );

    const updatesNeeded = Object.values({ ...tsWorkflows, ...yamlWorkflows }).flatMap((w) => {
      const trimStrings = <T>(obj: T): T =>
        obj &&
        JSON.parse(JSON.stringify(obj), (_key, value) =>
          typeof value === "string" ? value.trim() : value,
        );
      const ts = trimStrings(tsWorkflows[w.name]);
      const yaml = trimStrings(yamlWorkflows[w.name]);
      try {
        const suffixes = [ts, yaml].map((w) => (w?.yaml.trim() ? "content" : "no content"));
        if (suffixes[0] !== suffixes[1]) {
          throw new Error(`ts has ${suffixes[0]}, but yaml has ${suffixes[1]}`);
        }
        assert.deepStrictEqual(ts?.workflow, yaml?.workflow);
      } catch (error) {
        let message = String(error);
        if (message.includes("Expected values to be strictly deep-equal:")) {
          message = message.split("\n").slice(3).join("\n");
        }
        const reason = `Workflow ${w.name} was out of date: ${message}`;
        return { name: w.name, reason, ts, yaml };
      }

      if (input.force.includes("*") || input.force.includes(w.name)) {
        return { name: w.name, reason: "Forced update", ts, yaml };
      }

      return [];
    });

    const updateMessage = updatesNeeded.length
      ? `Updates were needed:\n\n${updatesNeeded.map((u) => u.reason).join("\n")}`
      : null;

    return next({
      ctx: {
        yamlWorkflowsDir,
        tsWorkflowsDir,
        tsWorkflowFileNames,
        yamlWorkflowFileNames,
        tsWorkflows,
        yamlWorkflows,
        updatesNeeded,
        updateMessage,
      },
    });
  });

const router = t.router({
  fromTs: workflowsProcedure
    .meta({ description: "Generate YAML workflows from TS workflows" })
    .mutation(async ({ ctx, input }) => {
      for (const { name, ts: tsWorkflow } of ctx.updatesNeeded) {
        const yamlPath = path.join(ctx.yamlWorkflowsDir, `${name}.yml`);
        if (!tsWorkflow) {
          console.error(`${yamlPath} missing ts. run "from-yaml" or delete manually`);
          continue;
        }

        if (!input.dryRun) await fs.writeFile(yamlPath, tsWorkflow.yaml);
      }
      if (ctx.updateMessage && process.env.CI) throw new Error(ctx.updateMessage);
      return ctx.updateMessage;
    }),
  fromYaml: workflowsProcedure
    .meta({
      description:
        "Generate TS workflows from YAML workflows. Will attempt to convert multiline strings to dedent expressions - make sure you check the output.",
    })
    .mutation(async ({ ctx, input }) => {
      for (const { name, yaml } of ctx.updatesNeeded) {
        const tsPath = path.join(ctx.tsWorkflowsDir, `${name}.ts`);
        const multilineStrings: string[] = [];
        let pojo = JSON.stringify(
          yaml.workflow,
          (_key, value) => {
            if (typeof value === "string" && value.includes("\n")) {
              multilineStrings.push(value);
              return `MULTILINE_STRING_${multilineStrings.length - 1}`;
            }
            return value;
          },
          2,
        );

        for (const [index, multilineString] of multilineStrings.entries()) {
          const escaped = multilineString.trimEnd().replaceAll("`", "\\`").replaceAll("${", "\\${");
          const marker = `MULTILINE_STRING_${index}`;
          const line = pojo.split("\n").find((line) => line.includes(marker));
          const indent = line?.match(/^(\s*)/)?.[1] || "";
          const indented = escaped.replaceAll("\n", `\n${indent}  `);
          const dedentExpression = [
            `dedent\``,
            `${indent}  ${indented}`, //
            `${indent}\``,
          ].join("\n");
          pojo = pojo.replace(`"${marker}"`, dedentExpression);
        }
        const ts = [
          ...(multilineStrings.length ? [`import dedent from "dedent";`] : []),
          `import { workflow } from "@jlarky/gha-ts/workflow-types";`,
          ``,
          `export default workflow(${pojo})`,
        ];
        if (!input.dryRun) {
          await fs.writeFile(tsPath, ts.join("\n"));
        }
      }
      if (ctx.updateMessage && process.env.CI) throw new Error(ctx.updateMessage);
      return ctx.updateMessage;
    }),

  githubScript: workflowsProcedure
    .meta({ description: "Locally run a GitHub script defined in a workflow" })
    .input(
      z.object({
        script: z
          .string()
          .transform((value, ctx) => {
            const parts = value.split(".");
            if (parts.length !== 3 || parts.filter(Boolean).length !== 3) {
              ctx.addIssue({ code: "custom", message: "Expected <workflow>.<job>.<step> syntax" });
              return z.NEVER;
            }
            const [workflow, job, step] = parts.map((p) => (p === "*" ? undefined : p));
            return { workflow, job, step };
          })
          .describe(
            "The step containing the script to run. Syntax: <workflow>.<job>.<step> - use * to match any e.g. `*.*.mystep` or `myworkflow.*.*` or `myworkflow.myjob.*`. An error will be thrown unless exactly one step is matches",
          )
          .meta({ positional: true }),
        githubToken: z.string().describe("The GitHub token to use"),
      }),
    )
    .mutation(async ({ ctx, input }) => {
      const workflow = Object.entries(ctx.tsWorkflows)
        .flatMap(([name, workflow]) => {
          return name === (input.script.workflow || name) ? workflow : [];
        })
        .find(Boolean);
      if (!workflow) throw new Error(`Workflow ${input.script.workflow} not found`);
      const scriptSteps = Object.entries(workflow.workflow.jobs).flatMap(([name, job]) => {
        if (name !== (input.script.job || name)) return [];
        if (!("steps" in job)) return [];
        const steps: Array<Step & { handler?: GithubScriptHandler }> = job.steps;
        return steps.flatMap((step) => {
          const nameMatch = step.name === (input.script.step || step.name);
          return typeof step.handler === "function" && nameMatch ? step : [];
        });
      });
      if (scriptSteps.length !== 1) {
        throw new Error(`Expected 1 script step, got ${scriptSteps.length}`, {
          cause: scriptSteps,
        });
      }

      const script = scriptSteps[0].handler;

      const { Octokit } = await import("@octokit/rest");
      const github = new Octokit({ auth: input.githubToken });
      github.log = { ...console, debug: () => {} };
      // todo: simulate the github context better to support more event trigger types. the most important ones are `context.repo` and `github`
      const variables = {
        context: {
          repo: { owner: "iterate", repo: "iterate" },
        } as GitHubScriptVariables["context"],
        github,
        core: {} as never,
        glob: {} as never,
        io: {} as never,
        require: (id: string) => require(id),
      } as GitHubScriptVariables;

      return await script!(variables);
    }),
});

createCli({ router }).run();
