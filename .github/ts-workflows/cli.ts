import * as fs from "node:fs/promises";
import * as path from "node:path";
import assert from "node:assert";
import { z } from "zod";
import { createCli } from "trpc-cli";
import { type Workflow } from "@jlarky/gha-ts/workflow-types";
import * as YAML from "yaml";
import { initTRPC } from "@trpc/server";

const t = initTRPC.create();

const workflowsProcedure = t.procedure
  .input(
    z.object({
      force: z
        .string()
        .array()
        .default([])
        .describe(
          "If set, these workflows will always be regenerated, even if they are up to date. This can be used to forcefully update formatting etc.",
        ),
      dryRun: z.boolean().default(false),
    }),
  )
  .use(async ({ next, input }) => {
    const tsWorkflowsDir = path.join(import.meta.dirname, "workflows");
    const yamlWorkflowsDir = path.join(import.meta.dirname, "../workflows");
    const tsWorkflowFileNames = await fs.readdir(tsWorkflowsDir);
    const yamlWorkflowFileNames = await fs.readdir(yamlWorkflowsDir);

    const tsWorkflowsList = await Promise.all(
      tsWorkflowFileNames.map(async (filename) => {
        const workflowModule = await import(path.join(tsWorkflowsDir, filename)).catch((e) => {
          console.error(`Error importing ${filename}:`, e);
          return { default: {} };
        });

        const workflow = workflowModule.default as Workflow;
        if (!workflow) throw new Error(`Workflow ${filename} is missing a default export`);
        let yaml = YAML.stringify(workflow, { lineWidth: 0 });
        yaml = `# this file is generated by ${filename}, do not edit it manually\n\n${yaml}`;
        return { filename, name: path.parse(filename).name, yaml, workflow };
      }),
    );
    const yamlWorkflowsList = await Promise.all(
      yamlWorkflowFileNames.map(async (filename) => {
        const yaml = await fs.readFile(path.join(yamlWorkflowsDir, filename), "utf8");
        const workflow = YAML.parse(yaml) as Workflow;
        return { filename, name: path.parse(filename).name, yaml, workflow };
      }),
    );
    const tsWorkflows = Object.fromEntries(
      tsWorkflowsList.filter((w) => w.workflow.jobs).map((w) => [w.name, w]),
    );
    const yamlWorkflows = Object.fromEntries(
      yamlWorkflowsList.filter((w) => w.workflow.jobs).map((w) => [w.name, w]),
    );

    const updatesNeeded = Object.values({ ...tsWorkflows, ...yamlWorkflows }).flatMap((w) => {
      const trimStrings = <T>(obj: T): T =>
        obj &&
        JSON.parse(JSON.stringify(obj), (_key, value) =>
          typeof value === "string" ? value.trim() : value,
        );
      const ts = trimStrings(tsWorkflows[w.name]);
      const yaml = trimStrings(yamlWorkflows[w.name]);
      try {
        const suffixes = [ts, yaml].map((w) => (w?.yaml.trim() ? "content" : "no content"));
        if (suffixes[0] !== suffixes[1]) {
          throw new Error(`ts has ${suffixes[0]}, but yaml has ${suffixes[1]}`);
        }
        assert.deepStrictEqual(ts?.workflow, yaml?.workflow);
      } catch (error) {
        let message = String(error);
        if (message.includes("Expected values to be strictly deep-equal:")) {
          message = message.split("\n").slice(3).join("\n");
        }
        const reason = `Workflow ${w.name} was out of date: ${message}`;
        return { name: w.name, reason, ts, yaml };
      }

      if (input.force.includes("*") || input.force.includes(w.name)) {
        return { name: w.name, reason: "Forced update", ts, yaml };
      }

      return [];
    });

    const updateMessage = updatesNeeded.length
      ? `Updates were needed:\n\n${updatesNeeded.map((u) => u.reason).join("\n")}`
      : null;

    return next({
      ctx: {
        yamlWorkflowsDir,
        tsWorkflowsDir,
        tsWorkflowFileNames,
        yamlWorkflowFileNames,
        tsWorkflows,
        yamlWorkflows,
        updatesNeeded,
        updateMessage,
      },
    });
  });

const router = t.router({
  fromTs: workflowsProcedure
    .meta({ description: "Generate YAML workflows from TS workflows" })
    .mutation(async ({ ctx, input }) => {
      for (const { name, ts: tsWorkflow } of ctx.updatesNeeded) {
        const yamlPath = path.join(ctx.yamlWorkflowsDir, `${name}.yml`);
        if (!tsWorkflow) {
          console.error(`${yamlPath} missing ts. run "from-yaml" or delete manually`);
          continue;
        }

        if (!input.dryRun) await fs.writeFile(yamlPath, tsWorkflow.yaml);
      }
      if (ctx.updateMessage && process.env.CI) throw new Error(ctx.updateMessage);
      return ctx.updateMessage;
    }),
  fromYaml: workflowsProcedure
    .meta({
      description:
        "Generate TS workflows from YAML workflows. Will attempt to convert multiline strings to dedent expressions - make sure you check the output.",
    })
    .mutation(async ({ ctx, input }) => {
      console.log("ctx.updatesNeeded", ctx.updatesNeeded);
      for (const { yaml } of ctx.updatesNeeded) {
        const tsPath = path.join(ctx.tsWorkflowsDir, `${yaml.name}.ts`);
        const multilineStrings: string[] = [];
        let pojo = JSON.stringify(
          yaml.workflow,
          (_key, value) => {
            if (typeof value === "string" && value.includes("\n")) {
              multilineStrings.push(value);
              return `MULTILINE_STRING_${multilineStrings.length - 1}`;
            }
            return value;
          },
          2,
        );

        for (const [index, multilineString] of multilineStrings.entries()) {
          const escaped = multilineString.trimEnd().replaceAll("`", "\\`").replaceAll("${", "\\${");
          const marker = `MULTILINE_STRING_${index}`;
          const line = pojo.split("\n").find((line) => line.includes(marker));
          const indent = line?.match(/^(\s*)/)?.[1] || "";
          const indented = escaped.replaceAll("\n", `\n${indent}  `);
          const dedentExpression = [
            `dedent\``,
            `${indent}  ${indented}`, //
            `${indent}\``,
          ].join("\n");
          pojo = pojo.replace(`"${marker}"`, dedentExpression);
        }
        const ts = [
          ...(multilineStrings.length ? [`import dedent from "dedent";`] : []),
          `import { workflow } from "@jlarky/gha-ts/workflow-types";`,
          ``,
          `export default workflow(${pojo})`,
        ];
        if (!input.dryRun) {
          await fs.writeFile(tsPath, ts.join("\n"));
        }
      }
      if (ctx.updateMessage && process.env.CI) throw new Error(ctx.updateMessage);
      return ctx.updateMessage;
    }),
});

createCli({ router }).run();
