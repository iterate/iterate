import * as fs from "node:fs/promises";
import * as path from "node:path";
import assert from "node:assert";
import { z } from "zod";
import { createCli } from "trpc-cli";
import { Workflow } from "@jlarky/gha-ts/workflow-types";
import * as YAML from "yaml";
import { initTRPC } from "@trpc/server";

const t = initTRPC.create();

const workflowsProcedure = t.procedure
  .input(
    z.object({
      force: z
        .string()
        .array()
        .default([])
        .describe(
          "If set, these workflows will always be regenerated, even if they are up to date. This can be used to forcefully update formatting etc.",
        ),
      dryRun: z.boolean().default(false),
    }),
  )
  .use(async ({ next, input }) => {
    const tsWorkflowsDir = path.join(import.meta.dirname, "workflows");
    const yamlWorkflowsDir = path.join(import.meta.dirname, "../workflows");
    const tsWorkflowFileNames = await fs.readdir(tsWorkflowsDir);
    const yamlWorkflowFileNames = await fs.readdir(yamlWorkflowsDir);

    const tsWorkflowsList = await Promise.all(
      tsWorkflowFileNames.map(async (filename) => {
        const workflowModule = await import(path.join(tsWorkflowsDir, filename)).catch(() => {
          return { default: {} };
        });
        const workflow = workflowModule.default as Workflow;
        let yaml = YAML.stringify(workflow);
        yaml = `# this file is generated by ${filename}, do not edit it manually\n\n${yaml}`;
        return { filename, name: path.parse(filename).name, yaml, workflow };
      }),
    );
    const yamlWorkflowsList = await Promise.all(
      yamlWorkflowFileNames.map(async (filename) => {
        const yaml = await fs.readFile(path.join(yamlWorkflowsDir, filename), "utf8");
        const workflow = YAML.parse(yaml) as Workflow;
        return { filename, name: path.parse(filename).name, yaml, workflow };
      }),
    );
    const tsWorkflows = Object.fromEntries(
      tsWorkflowsList.filter((w) => w.workflow.jobs).map((w) => [w.name, w]),
    );
    const yamlWorkflows = Object.fromEntries(
      yamlWorkflowsList.filter((w) => w.workflow.jobs).map((w) => [w.name, w]),
    );

    const updatesNeeded = Object.values({ ...tsWorkflows, ...yamlWorkflows }).flatMap((w) => {
      const ts = tsWorkflows[w.name];
      const yaml = yamlWorkflows[w.name];
      try {
        assert.deepStrictEqual(ts?.workflow, yaml?.workflow);
      } catch (error) {
        const message = String(error).split("\n").slice(3).join("\n");
        const reason = `Workflow ${w.name} was out of date: ${message}`;
        return { reason, ts, yaml };
      }

      if (input.force.includes("*") || input.force.includes(w.name)) {
        return { reason: "Forced update", ts, yaml };
      }

      return [];
    });

    const updateMessage = `Updates were needed:\n\n${updatesNeeded.map((u) => u.reason).join("\n")}`;

    return next({
      ctx: {
        yamlWorkflowsDir,
        tsWorkflowsDir,
        tsWorkflowFileNames,
        yamlWorkflowFileNames,
        tsWorkflows,
        yamlWorkflows,
        updatesNeeded,
        updateMessage,
      },
    });
  });

const router = t.router({
  fromTs: workflowsProcedure.mutation(async ({ ctx, input }) => {
    for (const { ts: tsWorkflow } of ctx.updatesNeeded) {
      const yamlPath = path.join(ctx.yamlWorkflowsDir, `${tsWorkflow.name}.yml`);
      if (!input.dryRun) await fs.writeFile(yamlPath, tsWorkflow.yaml);
    }
    if (ctx.updatesNeeded.length) throw new Error(ctx.updateMessage);
  }),
  fromYaml: workflowsProcedure.mutation(async ({ ctx, input }) => {
    for (const { yaml } of ctx.updatesNeeded) {
      const tsPath = path.join(ctx.tsWorkflowsDir, `${yaml.name}.ts`);
      const multilineStrings: string[] = [];
      let pojo = JSON.stringify(
        yaml.workflow,
        (_key, value) => {
          if (typeof value === "string" && value.includes("\n")) {
            multilineStrings.push(value);
            return `MULTILINE_STRING_${multilineStrings.length - 1}`;
          }
          return value;
        },
        2,
      );

      for (const [index, multilineString] of multilineStrings.entries()) {
        const escaped = multilineString.trimEnd().replaceAll("`", "\\`").replaceAll("${", "\\${");
        const marker = `MULTILINE_STRING_${index}`;
        const line = pojo.split("\n").find((line) => line.includes(marker));
        const indent = line?.match(/^(\s*)/)?.[1] || "";
        const indented = escaped.replaceAll("\n", `\n${indent}  `);
        const dedentExpression = [
          `dedent\``,
          `${indent}  ${indented}`, //
          `${indent}\``,
        ].join("\n");
        pojo = pojo.replace(`"${marker}"`, dedentExpression);
      }
      const ts = [
        ...(multilineStrings.length ? [`import dedent from "dedent";`] : []),
        `import { workflow } from "@jlarky/gha-ts/workflow-types";`,
        ``,
        `export default workflow(${pojo})`,
      ];
      if (!input.dryRun) {
        await fs.writeFile(tsPath, ts.join("\n"));
      }
    }
    if (ctx.updatesNeeded.length) throw new Error(ctx.updateMessage);
  }),
});

createCli({ router }).run();
