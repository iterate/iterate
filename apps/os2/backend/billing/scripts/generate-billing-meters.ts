#!/usr/bin/env tsx
/* eslint-disable no-console -- CLI script uses console for user output */

import { writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import type { BillingMeter, BillingMetersConfig, MeterCategory, MeterDirection } from "../types.ts";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const billingDir = join(__dirname, "..");

interface ModelsDevModel {
  id: string;
  name: string;
  tool_call?: boolean;
  limit?: {
    context?: number;
    output?: number;
  };
  cost?: {
    input?: number;
    output?: number;
    cache_read?: number;
    cache_write?: number;
  };
}

interface ModelsDevProvider {
  models?: Record<string, ModelsDevModel>;
}

interface ModelsDevData {
  anthropic?: ModelsDevProvider;
  openai?: ModelsDevProvider;
  google?: ModelsDevProvider;
  groq?: ModelsDevProvider;
  cerebras?: ModelsDevProvider;
  mistral?: ModelsDevProvider;
  deepseek?: ModelsDevProvider;
  xai?: ModelsDevProvider;
}

function getMeterKey(
  category: MeterCategory,
  provider: string,
  model: string | undefined,
  direction: MeterDirection | undefined,
): string {
  const parts = [category, provider];
  if (model) parts.push(model);
  if (direction && direction !== "both") parts.push(direction);
  return parts.join(":");
}

function getAggregateKey(
  category: MeterCategory,
  provider: string,
  direction?: MeterDirection,
): string {
  const parts = [category, provider];
  if (direction && direction !== "both") parts.push(direction);
  return parts.join(":");
}

async function fetchModelsDevData(): Promise<ModelsDevData | null> {
  try {
    console.log("Fetching models from models.dev API...");
    const response = await fetch("https://models.dev/api.json");
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return (await response.json()) as ModelsDevData;
  } catch (error) {
    console.error("Failed to fetch models.dev data:", error);
    return null;
  }
}

function processLLMProvider(
  providerName: string,
  providerData: ModelsDevProvider | undefined,
  meters: Record<string, BillingMeter>,
): void {
  if (!providerData?.models) return;

  for (const [modelId, model] of Object.entries(providerData.models)) {
    if (!model.cost) continue;

    if (model.cost.input !== undefined && model.cost.input > 0) {
      const key = getMeterKey("llm", providerName, modelId, "input");
      meters[key] = {
        key,
        displayName: `${model.name || modelId} (Input)`,
        category: "llm",
        provider: providerName,
        model: modelId,
        unit: "tokens",
        direction: "input",
        costPerUnit: model.cost.input / 1_000_000,
        aggregateKey: getAggregateKey("llm", providerName, "input"),
      };
    }

    if (model.cost.output !== undefined && model.cost.output > 0) {
      const key = getMeterKey("llm", providerName, modelId, "output");
      meters[key] = {
        key,
        displayName: `${model.name || modelId} (Output)`,
        category: "llm",
        provider: providerName,
        model: modelId,
        unit: "tokens",
        direction: "output",
        costPerUnit: model.cost.output / 1_000_000,
        aggregateKey: getAggregateKey("llm", providerName, "output"),
      };
    }

    if (model.cost.cache_read !== undefined && model.cost.cache_read > 0) {
      const key = getMeterKey("llm", providerName, `${modelId}-cache-read`, "input");
      meters[key] = {
        key,
        displayName: `${model.name || modelId} (Cache Read)`,
        category: "llm",
        provider: providerName,
        model: `${modelId}-cache-read`,
        unit: "tokens",
        direction: "input",
        costPerUnit: model.cost.cache_read / 1_000_000,
        aggregateKey: getAggregateKey("llm", providerName, "input"),
      };
    }
  }
}

function addSandboxMeters(meters: Record<string, BillingMeter>): void {
  const sandboxProviders = [
    { provider: "daytona", displayName: "Daytona", costPerSecond: 0.0001 },
    { provider: "local-docker", displayName: "Local Docker", costPerSecond: 0 },
  ];

  for (const { provider, displayName, costPerSecond } of sandboxProviders) {
    const key = getMeterKey("sandbox", provider, undefined, "both");
    meters[key] = {
      key,
      displayName: `${displayName} Sandbox CPU`,
      category: "sandbox",
      provider,
      unit: "seconds",
      direction: "both",
      costPerUnit: costPerSecond,
      aggregateKey: getAggregateKey("sandbox", provider),
    };
  }
}

function generateTypeScriptFile(config: BillingMetersConfig): string {
  let output = `// This file is auto-generated by scripts/generate-billing-meters.ts
// Do not edit manually - run 'pnpm generate:billing-meters' to update
// Generated at: ${config.generatedAt}
// Version: ${config.version}

import type { BillingMeter, BillingMetersConfig } from "./types.ts";

export const BILLING_METERS_CONFIG: BillingMetersConfig = {
  version: "${config.version}",
  generatedAt: "${config.generatedAt}",
  meters: {
`;

  const sortedKeys = Object.keys(config.meters).sort();
  for (const key of sortedKeys) {
    const meter = config.meters[key];
    output += `    "${key}": {\n`;
    output += `      key: "${meter.key}",\n`;
    output += `      displayName: "${meter.displayName}",\n`;
    output += `      category: "${meter.category}",\n`;
    output += `      provider: "${meter.provider}",\n`;
    if (meter.model) {
      output += `      model: "${meter.model}",\n`;
    }
    output += `      unit: "${meter.unit}",\n`;
    if (meter.direction) {
      output += `      direction: "${meter.direction}",\n`;
    }
    output += `      costPerUnit: ${meter.costPerUnit},\n`;
    if (meter.stripePriceId) {
      output += `      stripePriceId: "${meter.stripePriceId}",\n`;
    }
    if (meter.stripeProductId) {
      output += `      stripeProductId: "${meter.stripeProductId}",\n`;
    }
    output += `      aggregateKey: "${meter.aggregateKey}",\n`;
    output += `    } satisfies BillingMeter,\n`;
  }

  output += `  },
};

export const BILLING_METERS = BILLING_METERS_CONFIG.meters;

export function getMeter(key: string): BillingMeter | undefined {
  return BILLING_METERS[key];
}

export function getMetersByCategory(category: string): BillingMeter[] {
  return Object.values(BILLING_METERS).filter((m) => m.category === category);
}

export function getMetersByProvider(provider: string): BillingMeter[] {
  return Object.values(BILLING_METERS).filter((m) => m.provider === provider);
}

export function getMetersByAggregateKey(aggregateKey: string): BillingMeter[] {
  return Object.values(BILLING_METERS).filter((m) => m.aggregateKey === aggregateKey);
}
`;

  return output;
}

async function generateBillingMeters(): Promise<void> {
  console.log("Generating billing meters...\n");

  const meters: Record<string, BillingMeter> = {};

  const modelsDevData = await fetchModelsDevData();
  if (modelsDevData) {
    const llmProviders: Array<[string, ModelsDevProvider | undefined]> = [
      ["anthropic", modelsDevData.anthropic],
      ["openai", modelsDevData.openai],
      ["google", modelsDevData.google],
      ["groq", modelsDevData.groq],
      ["cerebras", modelsDevData.cerebras],
      ["mistral", modelsDevData.mistral],
      ["deepseek", modelsDevData.deepseek],
      ["xai", modelsDevData.xai],
    ];

    for (const [providerName, providerData] of llmProviders) {
      processLLMProvider(providerName, providerData, meters);
    }
  } else {
    console.log("Using fallback LLM pricing data...");
    addFallbackLLMMeters(meters);
  }

  addSandboxMeters(meters);

  const config: BillingMetersConfig = {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    meters,
  };

  const output = generateTypeScriptFile(config);
  const outputPath = join(billingDir, "meters.generated.ts");
  writeFileSync(outputPath, output);

  console.log(`\nGenerated ${outputPath}`);
  console.log(`\nMeter Statistics:`);
  console.log(`  Total meters: ${Object.keys(meters).length}`);

  const byCategory: Record<string, number> = {};
  const byProvider: Record<string, number> = {};
  for (const meter of Object.values(meters)) {
    byCategory[meter.category] = (byCategory[meter.category] || 0) + 1;
    byProvider[meter.provider] = (byProvider[meter.provider] || 0) + 1;
  }

  console.log("\n  By category:");
  for (const [cat, count] of Object.entries(byCategory).sort()) {
    console.log(`    ${cat}: ${count}`);
  }

  console.log("\n  By provider:");
  for (const [prov, count] of Object.entries(byProvider).sort()) {
    console.log(`    ${prov}: ${count}`);
  }
}

function addFallbackLLMMeters(meters: Record<string, BillingMeter>): void {
  const fallbackModels = [
    {
      provider: "anthropic",
      model: "claude-sonnet-4-20250514",
      name: "Claude Sonnet 4",
      input: 3,
      output: 15,
    },
    {
      provider: "anthropic",
      model: "claude-3-5-sonnet-20241022",
      name: "Claude 3.5 Sonnet",
      input: 3,
      output: 15,
    },
    {
      provider: "anthropic",
      model: "claude-3-5-haiku-20241022",
      name: "Claude 3.5 Haiku",
      input: 0.8,
      output: 4,
    },
    { provider: "openai", model: "gpt-4o", name: "GPT-4o", input: 2.5, output: 10 },
    { provider: "openai", model: "gpt-4o-mini", name: "GPT-4o Mini", input: 0.15, output: 0.6 },
    { provider: "openai", model: "o1", name: "o1", input: 15, output: 60 },
    { provider: "openai", model: "o3-mini", name: "o3-mini", input: 1.1, output: 4.4 },
    {
      provider: "google",
      model: "gemini-2.5-pro",
      name: "Gemini 2.5 Pro",
      input: 1.25,
      output: 10,
    },
    {
      provider: "google",
      model: "gemini-2.5-flash",
      name: "Gemini 2.5 Flash",
      input: 0.15,
      output: 0.6,
    },
    {
      provider: "deepseek",
      model: "deepseek-chat",
      name: "DeepSeek Chat",
      input: 0.14,
      output: 0.28,
    },
    {
      provider: "deepseek",
      model: "deepseek-reasoner",
      name: "DeepSeek Reasoner",
      input: 0.55,
      output: 2.19,
    },
  ];

  for (const { provider, model, name, input, output } of fallbackModels) {
    const inputKey = getMeterKey("llm", provider, model, "input");
    meters[inputKey] = {
      key: inputKey,
      displayName: `${name} (Input)`,
      category: "llm",
      provider,
      model,
      unit: "tokens",
      direction: "input",
      costPerUnit: input / 1_000_000,
      aggregateKey: getAggregateKey("llm", provider, "input"),
    };

    const outputKey = getMeterKey("llm", provider, model, "output");
    meters[outputKey] = {
      key: outputKey,
      displayName: `${name} (Output)`,
      category: "llm",
      provider,
      model,
      unit: "tokens",
      direction: "output",
      costPerUnit: output / 1_000_000,
      aggregateKey: getAggregateKey("llm", provider, "output"),
    };
  }
}

generateBillingMeters().catch(console.error);
