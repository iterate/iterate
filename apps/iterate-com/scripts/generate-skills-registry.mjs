import { mkdir, readdir, readFile, writeFile } from "node:fs/promises";
import { dirname, join, relative, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import matter from "gray-matter";

const scriptDir = dirname(fileURLToPath(import.meta.url));
const appDir = resolve(scriptDir, "..");
const repoRoot = resolve(appDir, "..", "..");
const sourceSkillsDir = resolve(repoRoot, "skills");
const outputFile = resolve(appDir, "backend/generated/skills-registry.ts");

function toPosixPath(pathname) {
  return pathname.replaceAll("\\", "/");
}

async function listFilesRecursively(dirPath) {
  const entries = await readdir(dirPath, { withFileTypes: true });
  const output = [];

  for (const entry of entries.toSorted((a, b) => a.name.localeCompare(b.name))) {
    const fullPath = join(dirPath, entry.name);
    if (entry.isDirectory()) {
      output.push(...(await listFilesRecursively(fullPath)));
      continue;
    }
    if (!entry.isFile()) continue;
    output.push(fullPath);
  }

  return output;
}

async function readSkillsFromRepo() {
  const rootEntries = await readdir(sourceSkillsDir, { withFileTypes: true }).catch((error) => {
    if (error && typeof error === "object" && "code" in error && error.code === "ENOENT") {
      return [];
    }
    throw error;
  });

  const skills = [];
  const fileContents = {};

  for (const entry of rootEntries.toSorted((a, b) => a.name.localeCompare(b.name))) {
    if (!entry.isDirectory()) continue;
    const skillDir = join(sourceSkillsDir, entry.name);
    const skillMdPath = join(skillDir, "SKILL.md");

    const skillMd = await readFile(skillMdPath, "utf8").catch((error) => {
      if (error && typeof error === "object" && "code" in error && error.code === "ENOENT") {
        return null;
      }
      throw error;
    });

    if (!skillMd) continue;

    const { data } = matter(skillMd);
    if (data.publish !== true) {
      continue;
    }

    if (typeof data.name !== "string" || data.name.length === 0) {
      throw new Error(
        `Missing frontmatter name in ${toPosixPath(relative(repoRoot, skillMdPath))}`,
      );
    }
    if (typeof data.description !== "string" || data.description.length === 0) {
      throw new Error(
        `Missing frontmatter description in ${toPosixPath(relative(repoRoot, skillMdPath))}`,
      );
    }
    if (data.name !== entry.name) {
      throw new Error(
        `Skill name "${data.name}" must match directory name "${entry.name}" in ${toPosixPath(relative(repoRoot, skillMdPath))}`,
      );
    }

    const absoluteFiles = await listFilesRecursively(skillDir);
    const files = absoluteFiles
      .map((absolutePath) => toPosixPath(relative(skillDir, absolutePath)))
      .toSorted((a, b) => a.localeCompare(b));

    if (!files.some((filePath) => filePath.toLowerCase() === "skill.md")) {
      throw new Error(`Skill ${data.name} must include SKILL.md`);
    }

    skills.push({
      name: data.name,
      description: data.description,
      files,
    });

    for (const filePath of files) {
      const absolutePath = join(skillDir, filePath);
      const content = await readFile(absolutePath, "utf8");
      fileContents[`${data.name}/${filePath}`] = content;
    }
  }

  return {
    skills,
    fileContents,
  };
}

async function main() {
  const registry = await readSkillsFromRepo();

  await mkdir(dirname(outputFile), { recursive: true });
  const source = `// This file is auto-generated by scripts/generate-skills-registry.mjs
// Do not edit by hand.

export interface WellKnownSkillEntry {
  name: string;
  description: string;
  files: string[];
}

export interface WellKnownSkillsRegistry {
  skills: WellKnownSkillEntry[];
  fileContents: Record<string, string>;
}

export const wellKnownSkillsRegistry: WellKnownSkillsRegistry = ${JSON.stringify(registry, null, 2)};
`;

  await writeFile(outputFile, source, "utf8");
}

await main();
