import { existsSync, mkdirSync, writeFileSync, rmSync, readFileSync } from "node:fs";
import { homedir } from "node:os";
import { join, dirname } from "node:path";
import { simpleGit } from "simple-git";
import { fetchBootstrapData } from "../bootstrap-refresh.ts";
import { createTRPCRouter, publicProcedure } from "./init.ts";

// Store for platform-injected env vars
const platformEnvVars: Record<string, string> = {};

// Store for cloned repos status and paths.
// Only contains CUSTOMER repos (from projectRepo table via getEnv).
// The iterate/iterate repo is baked into the Docker image, not tracked here.
const clonedReposStatus: Map<
  string,
  {
    status: "pending" | "cloning" | "cloned" | "error";
    error?: string;
    path?: string;
  }
> = new Map();

/**
 * Apply environment variables to the daemon process.
 * This function:
 * 1. Replaces vars in memory and process.env (removes stale keys)
 * 2. Writes them to ~/.iterate/.env file in dotenv format for pidnap
 */
export async function applyEnvVars(
  vars: Record<string, string>,
  descriptions?: Record<string, string>,
): Promise<{
  injectedCount: number;
  removedCount: number;
  envFilePath: string;
}> {
  const envFilePath = join(homedir(), ".iterate/.env");

  // Find keys to remove (were in platformEnvVars but not in new vars)
  const keysToRemove = Object.keys(platformEnvVars).filter((key) => !(key in vars));

  // Remove stale keys from process.env and platformEnvVars
  for (const key of keysToRemove) {
    delete process.env[key];
    delete platformEnvVars[key];
  }

  // Clear platformEnvVars and replace with new vars
  for (const key of Object.keys(platformEnvVars)) {
    delete platformEnvVars[key];
  }
  Object.assign(platformEnvVars, vars);
  Object.assign(process.env, vars);

  console.log(`[platform] Applied env vars: ${Object.keys(vars)}. Removed stale: ${keysToRemove}.`);

  // Write env vars in dotenv format for pidnap to parse. This file is NOT sourced
  // by bash - pidnap reads it directly using the dotenv library and injects vars
  // into managed processes. Double-quoted values preserve special chars literally.
  const envFileHeader = `# iterate sandbox environment variables
# =====================================
# This file is auto-generated by the iterate daemon. Changes will be overwritten.
# Format: dotenv (parsed by pidnap, NOT sourced by bash)
#
# SECRETS & API KEYS
# ------------------
# Secrets (like API keys) are NOT stored in this file. Instead, use the
# getIterateSecret() magic string in your requests. The egress proxy will
# replace it with the actual secret value.
#
# Format: getIterateSecret({secretKey: "<key>", userId?: "<user_id>", userEmail?: "<email>"})
#
# Examples:
#   # In HTTP headers
#   Authorization: Bearer getIterateSecret({secretKey: "openai_api_key"})
#
#   # In the URL path
#   curl https://api.example.com/getIterateSecret({secretKey: "api_key"})/data
#
#   # User-specific secrets (e.g., personal OAuth tokens)
#   Authorization: Bearer getIterateSecret({secretKey: "gmail.access_token", userId: "usr_123"})
#   Authorization: Bearer getIterateSecret({secretKey: "google_oauth", userEmail: "user@example.com"})
#
# The egress proxy (HTTPS_PROXY) intercepts all outbound requests and
# replaces getIterateSecret() strings in both headers AND the URL path.
# =====================================

NODE_USE_ENV_PROXY=1
`;

  const envFileContent =
    envFileHeader +
    Object.entries(platformEnvVars)
      // Double-quoted values in dotenv format. Escape backslashes and double quotes.
      .map(([key, value]) => {
        const escapedValue = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        const line = `${key}="${escapedValue}"`;
        // Add description as comment before env var if available
        if (descriptions?.[key]) {
          return `# ${descriptions[key]}\n${line}`;
        }
        return line;
      })
      .join("\n");

  // Check if content changed before writing
  mkdirSync(dirname(envFilePath), { recursive: true });
  const existingContent = existsSync(envFilePath) ? readFileSync(envFilePath, "utf-8") : "";
  const contentChanged = existingContent !== envFileContent;

  console.log("[platform] Env file check", {
    envFilePath,
    existingContentLength: existingContent.length,
    newContentLength: envFileContent.length,
    contentChanged,
  });

  if (contentChanged) {
    writeFileSync(envFilePath, envFileContent, { mode: 0o600 });
    console.log("[platform] Wrote new env file", {
      path: envFilePath,
      bytesWritten: envFileContent.length,
    });

    // Services watch the env file and restart themselves when it changes
  } else {
    console.log("[platform] Env vars unchanged, skipping write");
  }

  return {
    injectedCount: Object.keys(vars).length,
    removedCount: keysToRemove.length,
    envFilePath,
  };
}

/**
 * Clear any existing GitHub URL rewrites from git config and logout from gh CLI.
 * Called when GitHub is disconnected or before setting a new token.
 */
export async function clearGitHubCredentials(): Promise<void> {
  const git = simpleGit();

  try {
    const config = await git.listConfig("global");
    const githubUrlKeys = Object.keys(config.all).filter(
      (key) =>
        key.startsWith("url.https://x-access-token:") &&
        key.includes("github.com") &&
        // Don't clear the magic string config set by entry.sh - only clear real tokens
        !key.includes("getIterateSecret"),
    );
    for (const key of githubUrlKeys) {
      // Remove the .insteadOf suffix to get the section name for --unset
      const sectionKey = key.replace(/\.insteadof$/i, ".insteadOf");
      await git.raw(["config", "--global", "--unset", sectionKey]).catch(() => {
        // Ignore errors if key doesn't exist
      });
    }
    if (githubUrlKeys.length > 0) {
      console.log(
        `[platform] Cleared ${githubUrlKeys.length} stale GitHub credentials from git config`,
      );
    }
  } catch {
    // Ignore errors reading config
  }
}

export type RepoInfo = {
  url: string;
  branch: string;
  path: string;
  owner: string;
  name: string;
};

/**
 * Clone repositories. Called directly by bootstrap-refresh.ts.
 * Cloning happens asynchronously in the background.
 */
export function cloneRepos(repos: RepoInfo[]): void {
  for (const repo of repos) {
    const repoKey = `${repo.owner}/${repo.name}`;
    const expandedPath = repo.path.replace("~", homedir());
    const existing = clonedReposStatus.get(repoKey);

    // Skip if already cloning to prevent concurrent git operations
    if (existing?.status === "cloning") {
      console.log(`[platform] Skipping ${repoKey} - already cloning`);
      continue;
    }

    clonedReposStatus.set(repoKey, { status: "cloning", path: expandedPath });

    // Clone in background
    cloneRepo(repo.url, expandedPath, repo.branch)
      .then(() => {
        clonedReposStatus.set(repoKey, { status: "cloned", path: expandedPath });
        console.log(`[platform] Cloned ${repoKey} to ${expandedPath}`);
      })
      .catch((err) => {
        clonedReposStatus.set(repoKey, {
          status: "error",
          error: err instanceof Error ? err.message : String(err),
          path: expandedPath,
        });
        console.error(`[platform] Failed to clone ${repoKey}:`, err);
      });
  }
}

/**
 * Get the path to the first customer repository.
 * Returns null if no customer repos have been cloned yet.
 *
 * Note: This only returns customer repos (from projectRepo table).
 * The iterate/iterate repo is baked into the Docker image and not tracked here.
 */
export async function getCustomerRepoPath(): Promise<string> {
  if (!process.env.ITERATE_CUSTOMER_REPO_PATH) {
    await fetchBootstrapData();
  }
  if (!process.env.ITERATE_CUSTOMER_REPO_PATH) {
    throw new Error("ITERATE_CUSTOMER_REPO_PATH is not set");
  }
  return process.env.ITERATE_CUSTOMER_REPO_PATH;
}

/**
 * Check if an error is a proxy connection failure (mitmproxy not ready yet)
 */
function isProxyConnectionError(err: unknown): boolean {
  const msg = err instanceof Error ? err.message : String(err);
  return msg.includes("127.0.0.1 port 8888") || msg.includes("Couldn't connect to server");
}

/**
 * Sleep for a given number of milliseconds
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Clone a repository to the specified path.
 * Uses simple-git to avoid shell injection vulnerabilities.
 * Retries on proxy connection failures (mitmproxy may not be ready on startup).
 */
async function cloneRepo(
  url: string,
  targetPath: string,
  branch: string,
  retryCount = 0,
): Promise<void> {
  const MAX_RETRIES = 5;
  const RETRY_DELAY_MS = 2000; // 2 seconds between retries

  try {
    await cloneRepoInternal(url, targetPath, branch);
  } catch (err) {
    // Retry on proxy connection failures (mitmproxy may not be ready yet)
    if (isProxyConnectionError(err) && retryCount < MAX_RETRIES) {
      console.log(
        `[platform] Proxy not ready, retrying clone in ${RETRY_DELAY_MS}ms (attempt ${retryCount + 1}/${MAX_RETRIES})...`,
      );
      await sleep(RETRY_DELAY_MS);
      return cloneRepo(url, targetPath, branch, retryCount + 1);
    }
    throw err;
  }
}

/**
 * Internal clone implementation (no retry logic)
 */
async function cloneRepoInternal(url: string, targetPath: string, branch: string): Promise<void> {
  // Create parent directory if needed
  const parentDir = dirname(targetPath);
  if (!existsSync(parentDir)) {
    mkdirSync(parentDir, { recursive: true });
  }

  // If directory exists and has .git, update remote URL (fresh token) then fetch + reset
  if (existsSync(join(targetPath, ".git"))) {
    console.log(`[platform] Repo already exists at ${targetPath}, updating...`);
    const git = simpleGit(targetPath);
    // Update remote URL to use fresh token (GitHub tokens expire after 1 hour)
    await git.remote(["set-url", "origin", url]);
    await git.fetch("origin", branch);
    await git.reset(["--hard", `origin/${branch}`]);
    return;
  }

  // If directory exists but isn't a git repo, remove it
  if (existsSync(targetPath)) {
    rmSync(targetPath, { recursive: true, force: true });
  }

  // Clone the repo - try with branch first, fall back to default branch for empty repos
  const git = simpleGit();
  try {
    await git.clone(url, targetPath, ["--branch", branch, "--single-branch"]);
  } catch {
    // Clean up any partial clone before retry
    if (existsSync(targetPath)) {
      rmSync(targetPath, { recursive: true, force: true });
    }

    // If branch clone failed, try without --branch (handles empty repos or missing branches)
    console.log(`[platform] Branch clone failed, trying without --branch flag...`);
    try {
      await git.clone(url, targetPath);
    } catch (fallbackErr) {
      // Clean up partial state from failed fallback clone to prevent corrupt retry state
      if (existsSync(targetPath)) {
        rmSync(targetPath, { recursive: true, force: true });
      }
      throw fallbackErr;
    }
  }
}

export const platformRouter = createTRPCRouter({
  /**
   * Trigger an immediate refresh of bootstrap data from the control plane.
   * Called by the control plane after events like Slack OAuth to notify the daemon
   * that new env vars or tokens are available.
   */
  refreshEnv: publicProcedure.mutation(async () => {
    // Import dynamically to avoid circular dependencies
    const { fetchBootstrapData } = await import("../bootstrap-refresh.ts");
    try {
      await fetchBootstrapData();
      return { success: true };
    } catch (err) {
      console.error("[platform] Failed to refresh env:", err);
      return { success: false };
    }
  }),
});

export type PlatformRouter = typeof platformRouter;
