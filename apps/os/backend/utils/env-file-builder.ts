import type { UnifiedEnvVar } from "./env-vars.ts";

/**
 * Build the full ~/.iterate/.env file content from unified env vars.
 * This runs on the OS side and produces the dotenv string that gets pushed
 * to the daemon via tool.writeFile.
 */
export function buildEnvFileContent(
  envVars: UnifiedEnvVar[],
  options?: { skipProxy?: boolean },
): string {
  const { skipProxy } = options ?? {};

  const activeVars = envVars.filter((v) => v.source.type !== "recommended");
  const recommendedVars = envVars.filter((v) => v.source.type === "recommended");

  const envFileHeader = skipProxy
    ? `# iterate sandbox environment variables
# =====================================
# This file is auto-generated by the iterate control plane. Changes will be overwritten.
# Format: dotenv (parsed by pidnap, NOT sourced by bash)
#
# DANGEROUS MODE: Raw secrets enabled, egress proxy bypassed.
# Secrets are stored directly in this file as plaintext values.
# =====================================
`
    : `# iterate sandbox environment variables
# =====================================
# This file is auto-generated by the iterate control plane. Changes will be overwritten.
# Format: dotenv (parsed by pidnap, NOT sourced by bash)
#
# SECRETS & API KEYS
# ------------------
# Secrets (like API keys) are NOT stored in this file. Instead, use the
# getIterateSecret() magic string in your requests. The egress proxy will
# replace it with the actual secret value.
#
# Format: getIterateSecret({secretKey: "<key>", userId?: "<user_id>", userEmail?: "<email>"})
#
# Examples:
#   # In HTTP headers
#   Authorization: Bearer getIterateSecret({secretKey: "openai_api_key"})
#
#   # In the URL path
#   curl https://api.example.com/getIterateSecret({secretKey: "api_key"})/data
#
#   # User-specific secrets (e.g., personal OAuth tokens)
#   Authorization: Bearer getIterateSecret({secretKey: "gmail.access_token", userId: "usr_123"})
#   Authorization: Bearer getIterateSecret({secretKey: "google_oauth", userEmail: "user@example.com"})
#
# The egress proxy (HTTPS_PROXY) intercepts all outbound requests and
# replaces getIterateSecret() strings in both headers AND the URL path.
# =====================================
`;

  // Format active env vars
  const activeLines = activeVars.map((v) => {
    const escapedValue = v.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    const line = `${v.key}="${escapedValue}"`;
    if (v.description) {
      return `# ${v.description}\n${line}`;
    }
    return line;
  });

  const proxyAndCaLines = buildProxyAndCaLines(skipProxy);

  // Format recommended env vars as comments (so agent can discover them)
  let recommendedSection = "";
  if (recommendedVars.length > 0) {
    const recommendedLines = recommendedVars.map((v) => {
      const escapedValue = v.value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      const userEmail = v.source.type === "recommended" ? v.source.userEmail : "";
      return `# ${v.description || `Scoped to ${userEmail}`}\n#[recommended] ${v.key}="${escapedValue}"`;
    });
    recommendedSection = `
# =====================================
# RECOMMENDED (user-scoped secrets)
# To enable these, add them to your project's env vars in the Iterate dashboard.
# =====================================
${recommendedLines.join("\n")}
`;
  }

  return envFileHeader + proxyAndCaLines + activeLines.join("\n") + recommendedSection;
}

/**
 * Build proxy and CA env var lines for the .env file.
 * In normal mode, routes traffic through mitmproxy with its CA cert.
 * In skipProxy mode, clears all proxy/CA vars so traffic goes direct.
 *
 * Note: paths are hardcoded to the sandbox home directory (/home/iterate)
 * since this runs on the OS side, not inside the sandbox.
 */
function buildProxyAndCaLines(skipProxy?: boolean): string {
  if (skipProxy) {
    // In skipProxy mode, CA vars are omitted entirely (not set to "") so tools fall back to
    // the system CA store. Setting them to "" would override system defaults and break TLS.
    return `
# Proxy disabled - raw secrets mode enabled
# Proxy vars explicitly emptied; CA vars omitted so tools use system CA store.
HTTP_PROXY=""
HTTPS_PROXY=""
http_proxy=""
https_proxy=""
OTEL_EXPORTER_OTLP_TRACES_ENDPOINT="http://127.0.0.1:4318/v1/traces"
`;
  }

  // Hardcoded to sandbox home dir since this runs on the OS (Cloudflare Worker), not in the sandbox
  const home = "/home/iterate";
  const mitmDir = `${home}/.mitmproxy`;
  const ca = `${mitmDir}/mitmproxy-ca-cert.pem`;
  const proxy = "http://127.0.0.1:8888";
  const magicToken = encodeURIComponent("getIterateSecret({secretKey: 'github.access_token'})");

  return `
# Egress proxy configuration
# All sandbox HTTP traffic routes through mitmproxy -> egress proxy for secret injection
NODE_USE_ENV_PROXY=1
NODE_USE_SYSTEM_CA=1
HTTP_PROXY="${proxy}"
HTTPS_PROXY="${proxy}"
http_proxy="${proxy}"
https_proxy="${proxy}"
NO_PROXY="localhost,127.0.0.1,os.iterate.com"
no_proxy="localhost,127.0.0.1,os.iterate.com"
GIT_SSL_CAINFO="${ca}"
SSL_CERT_FILE="${ca}"
SSL_CERT_DIR="${mitmDir}"
REQUESTS_CA_BUNDLE="${ca}"
CURL_CA_BUNDLE="${ca}"
NODE_EXTRA_CA_CERTS="${ca}"
GITHUB_MAGIC_TOKEN="${magicToken}"
OTEL_EXPORTER_OTLP_TRACES_ENDPOINT="http://127.0.0.1:4318/v1/traces"
`;
}
