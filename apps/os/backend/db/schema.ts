import {
  pgTable,
  timestamp,
  text,
  uniqueIndex,
  jsonb,
  index,
  bigserial,
} from "drizzle-orm/pg-core";
import { typeid } from "typeid-js";
import { isNull, relations } from "drizzle-orm";
import type { SlackEvent } from "@slack/web-api";
import type { DynamicClientInfo } from "../auth/oauth-state-schemas.ts";

// User's role within an organization (used in organizationUserMembership table)
// Note: This is different from user.role which is for Better Auth's admin plugin
//
// Role definitions:
// - member: Default role with standard access to organization resources
// - admin: Elevated privileges; can manage organization settings and update member roles
// - owner: Highest organization role; can manage members, admins, and delete organizations
// - guest: Restricted access; typically for Slack restricted/ultra_restricted users; cannot perform privileged actions like connecting MCP servers
// - external: For external users (e.g., Slack Connect users from other workspaces)
export const UserRole = ["member", "admin", "owner", "guest", "external"] as const;
export type UserRole = (typeof UserRole)[number];

export const withTimestamps = {
  createdAt: timestamp().defaultNow().notNull(),
  updatedAt: timestamp()
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
};

export const iterateId = <P extends string>(prefix: P) =>
  text()
    .primaryKey()
    .$defaultFn(() => typeid(prefix).toString() as `${P}_${string}`);

// #region ========== Better Auth Schema ==========
export const user = pgTable("user", (t) => ({
  id: iterateId("usr"),
  name: t.text().notNull(),
  // In the case of Slack bots, this will be a synthetic email address (e.g. "slack-connect-{slackUserId}@external.slack.iterate.com")
  // that is generated by us to maintain the invariant that all users must have email addresses.
  // Regular Slack users use their actual email from their Slack profile.
  email: t.text().notNull().unique(),
  emailVerified: t.boolean().default(false).notNull(),
  image: t.text(),
  // https://www.better-auth.com/docs/plugins/admin#schema
  role: t.text().default("user"),
  debugMode: t.boolean().default(false),
  banned: t.boolean(),
  banReason: t.text(),
  banExpires: t.timestamp(),
  // Indicates whether this user is a bot (e.g., from Slack's `is_bot` field).
  // Bot users are typically created when syncing Slack workspace members and are used
  // to track bot messages in conversations.
  isBot: t.boolean().default(false).notNull(),
  ...withTimestamps,
}));
export const userRelations = relations(user, ({ many }) => ({
  session: many(session),
  account: many(account),
  organizationUserMembership: many(organizationUserMembership),
  providerSpecificUserMapping: many(providerUserMapping),
}));

export const session = pgTable("session", (t) => ({
  id: iterateId("ses"),
  expiresAt: t.timestamp().notNull(),
  token: t.text().notNull().unique(),
  ipAddress: t.text(),
  userAgent: t.text(),
  userId: t
    .text()
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  // https://www.better-auth.com/docs/plugins/admin#schema
  impersonatedBy: t.text().references(() => user.id, { onDelete: "cascade" }),
  ...withTimestamps,
}));
export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const account = pgTable("account", (t) => ({
  id: iterateId("acc"),
  accountId: t.text().notNull(),
  providerId: t.text().notNull(),
  userId: t
    .text()
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: t.text(),
  refreshToken: t.text(),
  idToken: t.text(),
  accessTokenExpiresAt: t.timestamp(),
  refreshTokenExpiresAt: t.timestamp(),
  scope: t.text(),
  password: t.text(),
  ...withTimestamps,
}));
export const accountRelations = relations(account, ({ one, many }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
  installationAccountsPermissions: many(installationAccountsPermissions),
}));

export const verification = pgTable("verification", (t) => ({
  id: iterateId("ver"),
  identifier: t.text().notNull(),
  value: t.text().notNull(),
  expiresAt: t.timestamp().notNull(),
  ...withTimestamps,
}));

// #endregion ========== Better Auth Schema ==========

export const dynamicClientInfo = pgTable(
  "dynamic_client_info",
  (t) => ({
    id: iterateId("dci"),
    providerId: t.text().notNull(),
    userId: t
      .text()
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    clientId: t.text().notNull(),
    clientInfo: t.jsonb().$type<DynamicClientInfo>().notNull(),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.providerId, t.userId)],
);

export const files = pgTable("files", (t) => ({
  id: iterateId("file"),
  status: t
    .text({ enum: ["started", "completed", "error"] })
    .notNull()
    .default("started"),
  filename: t.text(),
  fileSize: t.integer(),
  mimeType: t.text(),
  openAIFileId: t.text(),
  installationId: t.text().references(() => installation.id, { onDelete: "cascade" }),
  ...withTimestamps,
}));
export const filesRelations = relations(files, ({ one }) => ({
  installation: one(installation, {
    fields: [files.installationId],
    references: [installation.id],
  }),
}));

export const installation = pgTable("installation", (t) => ({
  id: iterateId("ins"),
  slug: t.text().notNull().unique(),
  name: t.text().notNull(),
  organizationId: t
    .text()
    .notNull()
    .references(() => organization.id, { onDelete: "cascade" }),
  // Onboarding agent name. Semantics: if null, user is done with onboarding.
  // If not null, use that agent to get onboarding information from it.
  onboardingAgentName: t.text(),
  ...withTimestamps,
}));

export const installationRelations = relations(installation, ({ one, many }) => ({
  organization: one(organization, {
    fields: [installation.organizationId],
    references: [organization.id],
  }),
  sources: many(iterateConfigSource),
  installationAccountsPermissions: many(installationAccountsPermissions),
  files: many(files),
  providerInstallationMappings: many(providerInstallationMapping),
  slackWebhookEvents: many(slackWebhookEvent),
  iterateConfigs: many(iterateConfig),
  agentInstances: many(agentInstance),
  mcpConnectionParams: many(mcpConnectionParam),
  slackChannels: many(slackChannel),
  slackChannelOverrides: many(slackChannelOverride),
  onboardingEvents: many(installationOnboardingEvent),
  builds: many(builds),
}));

export const organization = pgTable("organization", (t) => ({
  id: iterateId("org"),
  name: t.text().notNull(),
  stripeCustomerId: t.text(),
  ...withTimestamps,
}));
export const organizationRelations = relations(organization, ({ many }) => ({
  installations: many(installation),
  members: many(organizationUserMembership),
}));

export const installationAccountsPermissions = pgTable(
  "installation_accounts_permissions",
  (t) => ({
    id: iterateId("iap"),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    accountId: t
      .text()
      .notNull()
      .references(() => account.id, { onDelete: "cascade" }),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.installationId, t.accountId)],
);
export const installationAccountsPermissionsRelations = relations(
  installationAccountsPermissions,
  ({ one }) => ({
    installation: one(installation, {
      fields: [installationAccountsPermissions.installationId],
      references: [installation.id],
    }),
    account: one(account, {
      fields: [installationAccountsPermissions.accountId],
      references: [account.id],
    }),
  }),
);

export const providerUserMapping = pgTable(
  "provider_user_mapping",
  (t) => ({
    id: iterateId("pum"),
    providerId: t.text().notNull(),
    internalUserId: t
      .text()
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    externalId: t.text().notNull(),
    // OPTIONAL: Which installation's sync discovered/created this mapping
    installationId: t.text().references(() => installation.id, { onDelete: "cascade" }),
    // OPTIONAL: The user's actual home team ID, only set if external to the installation's workspace
    externalUserTeamId: t.text(),
    providerMetadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.providerId, t.installationId, t.externalId)],
);
export const providerUserMappingRelations = relations(providerUserMapping, ({ one }) => ({
  internalUser: one(user, {
    fields: [providerUserMapping.internalUserId],
    references: [user.id],
  }),
}));

export const providerInstallationMapping = pgTable(
  "provider_installation_mapping",
  (t) => ({
    id: iterateId("pim"),
    providerId: t.text().notNull(),
    internalInstallationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    externalId: t.text().notNull(),
    providerMetadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.providerId, t.externalId)],
);
export const providerInstallationMappingRelations = relations(
  providerInstallationMapping,
  ({ one }) => ({
    internalInstallation: one(installation, {
      fields: [providerInstallationMapping.internalInstallationId],
      references: [installation.id],
    }),
  }),
);

export const slackChannel = pgTable(
  "slack_channel",
  (t) => ({
    id: iterateId("slc"),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    externalId: t.text().notNull(),
    name: t.text().notNull(),
    isShared: t.boolean().default(false).notNull(),
    isExtShared: t.boolean().default(false).notNull(),
    isPrivate: t.boolean().default(false).notNull(),
    isArchived: t.boolean().default(false).notNull(),
    providerMetadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.installationId, t.externalId),
    index().on(t.installationId),
    index().on(t.name),
  ],
);

export const slackChannelRelations = relations(slackChannel, ({ one }) => ({
  installation: one(installation, {
    fields: [slackChannel.installationId],
    references: [installation.id],
  }),
}));

export const slackChannelOverride = pgTable(
  "slack_channel_override",
  (t) => ({
    id: iterateId("sco"),
    slackChannelId: t.text().notNull(),
    slackTeamId: t.text().notNull(),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    reason: t.text(),
    metadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.slackChannelId, t.slackTeamId),
    index().on(t.slackChannelId),
    index().on(t.installationId),
  ],
);

export const slackChannelOverrideRelations = relations(slackChannelOverride, ({ one }) => ({
  installation: one(installation, {
    fields: [slackChannelOverride.installationId],
    references: [installation.id],
  }),
}));

export const organizationUserMembership = pgTable(
  "organization_user_membership",
  (t) => ({
    id: iterateId("member"),
    organizationId: t
      .text()
      .notNull()
      .references(() => organization.id, { onDelete: "cascade" }),
    userId: t
      .text()
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    role: t
      .text({ enum: [...UserRole] })
      .notNull()
      .default("member"),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.userId, t.organizationId)],
);
export const organizationUserMembershipRelations = relations(
  organizationUserMembership,
  ({ one }) => ({
    organization: one(organization, {
      fields: [organizationUserMembership.organizationId],
      references: [organization.id],
    }),
    user: one(user, {
      fields: [organizationUserMembership.userId],
      references: [user.id],
    }),
  }),
);

export const agentInstance = pgTable(
  "agent_instance",
  (t) => ({
    id: iterateId("agnt"),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    className: t.text().notNull(),
    durableObjectName: t.text().notNull(),
    durableObjectId: t.text().notNull(),
    routingKey: t.text().unique(),
    metadata: jsonb().$type<Record<string, unknown>>().default({}).notNull(),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.installationId, t.durableObjectName),
    uniqueIndex().on(t.durableObjectId),
    index().on(t.installationId),
    index().on(t.className),
  ],
);

export const agentInstanceRelations = relations(agentInstance, ({ one }) => ({
  installation: one(installation, {
    fields: [agentInstance.installationId],
    references: [installation.id],
  }),
}));

export const slackWebhookEvent = pgTable(
  "slack_webhook_event",
  (t) => ({
    id: iterateId("slackevent"),
    data: t.jsonb().$type<SlackEvent>().notNull(),
    ts: t.text("ts"),
    thread_ts: t.text("thread_ts"),
    channel: t.text("channel"),
    type: t.text("type"),
    subtype: t.text("subtype"),
    user: t.text("user"),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    ...withTimestamps,
  }),
  (table) => [
    index("channel_or_thread_messages").on(table.channel, table.ts, table.thread_ts, table.type),
    index().on(table.installationId),
  ],
);

export const slackWebhookEventRelations = relations(slackWebhookEvent, ({ one }) => ({
  installation: one(installation, {
    fields: [slackWebhookEvent.installationId],
    references: [installation.id],
  }),
}));

export const iterateConfigSource = pgTable(
  "iterate_config_source",
  (t) => ({
    id: iterateId("ics"),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    provider: t.text({ enum: ["github"] }).notNull(),
    accountId: t.text().notNull(),
    repoId: t.integer().notNull(),
    branch: t.text().notNull(),
    path: t.text(),
    deactivatedAt: t.timestamp(),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.installationId, t.provider).where(isNull(t.deactivatedAt))],
);

export const iterateConfigSourceRelations = relations(iterateConfigSource, ({ one }) => ({
  installation: one(installation, {
    fields: [iterateConfigSource.installationId],
    references: [installation.id],
  }),
}));

export const iterateConfig = pgTable(
  "iterate_config",
  (t) => ({
    id: iterateId("icfg"),
    buildId: t
      .text()
      .notNull()
      .references(() => builds.id, { onDelete: "cascade" }),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.installationId)],
);

export const iterateConfigRelations = relations(iterateConfig, ({ one }) => ({
  installation: one(installation, {
    fields: [iterateConfig.installationId],
    references: [installation.id],
  }),
  build: one(builds, {
    fields: [iterateConfig.buildId],
    references: [builds.id],
  }),
}));

export const builds = pgTable("builds", (t) => ({
  id: iterateId("build"),
  status: t.text({ enum: ["complete", "failed", "in_progress", "queued"] }).notNull(),
  commitHash: t.text().notNull(),
  commitMessage: t.text().notNull(),
  files: t.jsonb().$type<{ path: string; content: string }[]>().notNull(),
  config: t.jsonb().$type<{ contextRules?: any[] } | null>(),
  iterateWorkflowRunId: t.text(),
  webhookIterateId: t.text().notNull(),
  installationId: t
    .text()
    .notNull()
    .references(() => installation.id, { onDelete: "cascade" }),
  completedAt: t.timestamp(),
  failureReason: t.text(),
  ...withTimestamps,
}));

export const buildsRelations = relations(builds, ({ one }) => ({
  installation: one(installation, {
    fields: [builds.installationId],
    references: [installation.id],
  }),
}));

export const mcpConnectionParam = pgTable(
  "mcp_connection_param",
  (t) => ({
    id: iterateId("mcp"),
    connectionKey: t.text().notNull(),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    paramKey: t.text().notNull(),
    paramValue: t.text().notNull(),
    paramType: t.text({ enum: ["header", "query_param"] }).notNull(),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.installationId, t.connectionKey, t.paramKey, t.paramType),
    index().on(t.installationId),
    index().on(t.connectionKey),
  ],
);

export const mcpConnectionParamRelations = relations(mcpConnectionParam, ({ one }) => ({
  installation: one(installation, {
    fields: [mcpConnectionParam.installationId],
    references: [installation.id],
  }),
}));

export const installationOnboardingEvent = pgTable(
  "installation_onboarding_event",
  (t) => ({
    id: iterateId("onbe"),
    installationId: t
      .text()
      .notNull()
      .references(() => installation.id, { onDelete: "cascade" }),
    organizationId: t
      .text()
      .notNull()
      .references(() => organization.id, { onDelete: "cascade" }),
    eventType: t.text().notNull(),
    category: t.text({ enum: ["system", "user"] }).notNull(),
    detail: t.text(),
    metadata: jsonb().$type<Record<string, unknown>>().default({}).notNull(),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.installationId, t.eventType),
    index().on(t.installationId),
    index().on(t.installationId, t.category),
    index().on(t.category),
  ],
);

export const outboxEvent = pgTable("outbox_event", (t) => ({
  id: bigserial("id", { mode: "number" }).primaryKey(),
  name: t.text().notNull(),
  payload: jsonb().$type<Record<string, unknown>>().notNull(),
  ...withTimestamps,
}));
