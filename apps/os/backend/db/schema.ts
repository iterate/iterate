import {
  pgTable,
  timestamp,
  text,
  uniqueIndex,
  jsonb,
  index,
  bigserial,
} from "drizzle-orm/pg-core";
import { typeid } from "typeid-js";
import { relations } from "drizzle-orm";
import type { SlackEvent } from "@slack/web-api";
import type { DynamicClientInfo } from "../auth/oauth-state-schemas.ts";

// User's role within an organization (used in organizationUserMembership table)
// Note: This is different from user.role which is for Better Auth's admin plugin
//
// Role definitions:
// - member: Default role with standard access to organization resources
// - admin: Elevated privileges; can manage organization settings and update member roles
// - owner: Highest organization role; can manage members, admins, and delete organizations
// - guest: Restricted access; typically for Slack restricted/ultra_restricted users; cannot perform privileged actions like connecting MCP servers
// - external: For external users (e.g., Slack Connect users from other workspaces)
export const UserRole = ["member", "admin", "owner", "guest", "external"] as const;
export type UserRole = (typeof UserRole)[number];

export const withTimestamps = {
  createdAt: timestamp().defaultNow().notNull(),
  updatedAt: timestamp()
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
};

export const iterateId = <P extends string>(prefix: P) =>
  text()
    // .$type<`${P}_${string}`>() // TODO: Uncomment this when we have a zod validator
    .primaryKey()
    .$defaultFn(() => typeid(prefix).toString() as `${P}_${string}`);

// #region ========== Better Auth Schema ==========
export const user = pgTable("user", (t) => ({
  id: iterateId("usr"),
  name: t.text().notNull(),
  // In the case of Slack bots, this will be a synthetic email address (e.g. "slack-connect-{slackUserId}@external.slack.iterate.com")
  // that is generated by us to maintain the invariant that all users must have email addresses.
  // Regular Slack users use their actual email from their Slack profile.
  email: t.text().notNull().unique(),
  emailVerified: t.boolean().default(false).notNull(),
  image: t.text(),
  // https://www.better-auth.com/docs/plugins/admin#schema
  role: t.text().default("user"),
  debugMode: t.boolean().default(false),
  banned: t.boolean(),
  banReason: t.text(),
  banExpires: t.timestamp(),
  // Indicates whether this user is a bot (e.g., from Slack's `is_bot` field).
  // Bot users are typically created when syncing Slack workspace members and are used
  // to track bot messages in conversations.
  isBot: t.boolean().default(false).notNull(),
  ...withTimestamps,
}));
export const userRelations = relations(user, ({ many }) => ({
  session: many(session),
  account: many(account),
  organizationUserMembership: many(organizationUserMembership),
  providerSpecificUserMapping: many(providerUserMapping),
}));

export const session = pgTable("session", (t) => ({
  id: iterateId("ses"),
  expiresAt: t.timestamp().notNull(),
  token: t.text().notNull().unique(),
  ipAddress: t.text(),
  userAgent: t.text(),
  userId: t
    .text()
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  // https://www.better-auth.com/docs/plugins/admin#schema
  impersonatedBy: t.text().references(() => user.id, { onDelete: "cascade" }),
  ...withTimestamps,
}));
export const sessionRelations = relations(session, ({ one }) => ({
  user: one(user, {
    fields: [session.userId],
    references: [user.id],
  }),
}));

export const account = pgTable("account", (t) => ({
  id: iterateId("acc"),
  accountId: t.text().notNull(),
  providerId: t.text().notNull(),
  userId: t
    .text()
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  accessToken: t.text(),
  refreshToken: t.text(),
  idToken: t.text(),
  accessTokenExpiresAt: t.timestamp(),
  refreshTokenExpiresAt: t.timestamp(),
  scope: t.text(),
  password: t.text(),
  ...withTimestamps,
}));
export const accountRelations = relations(account, ({ one, many }) => ({
  user: one(user, {
    fields: [account.userId],
    references: [user.id],
  }),
  estateAccountsPermissions: many(estateAccountsPermissions),
}));

export const verification = pgTable("verification", (t) => ({
  id: iterateId("ver"),
  identifier: t.text().notNull(),
  value: t.text().notNull(),
  expiresAt: t.timestamp().notNull(),
  ...withTimestamps,
}));

// #endregion ========== Better Auth Schema ==========

export const dynamicClientInfo = pgTable(
  "dynamic_client_info",
  (t) => ({
    id: iterateId("dci"),
    providerId: t.text().notNull(),
    userId: t
      .text()
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    clientId: t.text().notNull(),
    clientInfo: t.jsonb().$type<DynamicClientInfo>().notNull(),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.providerId, t.userId)],
);

export const files = pgTable("files", (t) => ({
  id: iterateId("file"),
  status: t
    .text({ enum: ["started", "completed", "error"] })
    .notNull()
    .default("started"),
  filename: t.text(),
  fileSize: t.integer(), // Size in bytes
  mimeType: t.text(),
  openAIFileId: t.text(),
  estateId: t.text().references(() => estate.id, { onDelete: "cascade" }),
  ...withTimestamps,
}));
export const filesRelations = relations(files, ({ one }) => ({
  estate: one(estate, {
    fields: [files.estateId],
    references: [estate.id],
  }),
}));

export const estate = pgTable("estate", (t) => ({
  id: iterateId("est"),
  name: t.text().notNull(),
  organizationId: t
    .text()
    .notNull()
    .references(() => organization.id, { onDelete: "cascade" }),
  connectedRepoId: t.integer(),
  connectedRepoRef: t.text(),
  connectedRepoPath: t.text(),
  // Onboarding agent name. Semantics: if null, user is done with onboarding.
  // If not null, use that agent to get onboarding information from it.
  onboardingAgentName: t.text(),
  ...withTimestamps,
}));

export const estateRelations = relations(estate, ({ one, many }) => ({
  organization: one(organization, {
    fields: [estate.organizationId],
    references: [organization.id],
  }),
  estateAccountsPermissions: many(estateAccountsPermissions),
  files: many(files),
  providerSpecificEstateMapping: many(providerEstateMapping),
  slackWebhookEvents: many(slackWebhookEvent),
  iterateConfigs: many(iterateConfig),
  agentInstances: many(agentInstance),
  mcpConnectionParam: many(mcpConnectionParam),
  slackChannels: many(slackChannel),
  slackChannelEstateOverrides: many(slackChannelEstateOverride),
}));

export const organization = pgTable("organization", (t) => ({
  id: iterateId("org"),
  name: t.text().notNull(),
  stripeCustomerId: t.text(),
  ...withTimestamps,
}));
export const organizationRelations = relations(organization, ({ many }) => ({
  estates: many(estate),
  members: many(organizationUserMembership),
}));

export const estateAccountsPermissions = pgTable(
  "estate_accounts_permissions",
  (t) => ({
    id: iterateId("eap"),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    accountId: t
      .text()
      .notNull()
      .references(() => account.id, { onDelete: "cascade" }),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.estateId, t.accountId)],
);
export const estateAccountsPermissionsRelations = relations(
  estateAccountsPermissions,
  ({ one }) => ({
    estate: one(estate, {
      fields: [estateAccountsPermissions.estateId],
      references: [estate.id],
    }),
    account: one(account, {
      fields: [estateAccountsPermissions.accountId],
      references: [account.id],
    }),
  }),
);

export const providerUserMapping = pgTable(
  "provider_user_mapping",
  (t) => ({
    id: iterateId("pum"),
    providerId: t.text().notNull(),
    internalUserId: t
      .text()
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    externalId: t.text().notNull(), // Slack user ID (e.g., U_NICK_123, USLACKBOT)
    // OPTIONAL: Which estate's sync discovered/created this mapping
    // This represents the "observing estate's perspective" on this user.
    // Nullable to allow existing rows from before this field was added.
    estateId: t.text().references(() => estate.id, { onDelete: "cascade" }),
    // OPTIONAL: The user's actual home team ID, only set if external to the estate's workspace
    // - null = user is from the estate's own OAuth'd workspace (internal user)
    // - set = user is from a different workspace discovered via Slack Connect (external user)
    // Example: Estate A (owns T_ITERATE) syncs Slack Connect user from T_STRIPE
    //   â†’ estateId = estate_A, externalUserTeamId = T_STRIPE
    externalUserTeamId: t.text(),
    providerMetadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [
    // Global uniqueness: (provider, estate, externalId)
    // Each external user can have only one mapping per estate
    uniqueIndex().on(t.providerId, t.estateId, t.externalId),
  ],
);
export const providerUserMappingRelations = relations(providerUserMapping, ({ one }) => ({
  internalUser: one(user, {
    fields: [providerUserMapping.internalUserId],
    references: [user.id],
  }),
}));

export const providerEstateMapping = pgTable(
  "provider_estate_mapping",
  (t) => ({
    id: iterateId("pem"),
    providerId: t.text().notNull(),
    internalEstateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    externalId: t.text().notNull(),
    providerMetadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.providerId, t.externalId)],
);
export const providerEstateMappingRelations = relations(providerEstateMapping, ({ one }) => ({
  internalEstate: one(estate, {
    fields: [providerEstateMapping.internalEstateId],
    references: [estate.id],
  }),
}));

export const slackChannel = pgTable(
  "slack_channel",
  (t) => ({
    id: iterateId("slc"),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    externalId: t.text().notNull(),
    name: t.text().notNull(),
    isShared: t.boolean().default(false).notNull(),
    isExtShared: t.boolean().default(false).notNull(),
    isPrivate: t.boolean().default(false).notNull(),
    isArchived: t.boolean().default(false).notNull(),
    providerMetadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.estateId, t.externalId), index().on(t.estateId), index().on(t.name)],
);

export const slackChannelRelations = relations(slackChannel, ({ one }) => ({
  estate: one(estate, {
    fields: [slackChannel.estateId],
    references: [estate.id],
  }),
}));

/**
 * Override table for routing Slack channels to specific estates.
 * When a webhook is received for a channel with an entry in this table,
 * the specified estate will be used instead of the default team_id â†’ estate mapping.
 *
 * Use cases:
 * - Route specific channels from a workspace to different estates
 * - Handle shared Slack Connect channels with custom routing
 * - Testing and development with specific channel routing
 */
export const slackChannelEstateOverride = pgTable(
  "slack_channel_estate_override",
  (t) => ({
    id: iterateId("sceo"),
    // The Slack channel ID to override routing for
    slackChannelId: t.text().notNull(),
    // The Slack team/workspace ID (for context/validation)
    slackTeamId: t.text().notNull(),
    // The estate ID to route this channel to
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    // Optional: reason for the override (for documentation)
    reason: t.text(),
    // Optional: metadata (e.g., who created it, when, why)
    metadata: t.jsonb().default({}),
    ...withTimestamps,
  }),
  (t) => [
    // Ensure each channel can only have one override
    uniqueIndex().on(t.slackChannelId, t.slackTeamId),
    // Index for fast lookups by channel
    index().on(t.slackChannelId),
    // Index for finding all overrides for an estate
    index().on(t.estateId),
  ],
);

export const slackChannelEstateOverrideRelations = relations(
  slackChannelEstateOverride,
  ({ one }) => ({
    estate: one(estate, {
      fields: [slackChannelEstateOverride.estateId],
      references: [estate.id],
    }),
  }),
);

export const organizationUserMembership = pgTable(
  "organization_user_membership",
  (t) => ({
    id: iterateId("member"),
    organizationId: t
      .text()
      .notNull()
      .references(() => organization.id, { onDelete: "cascade" }),
    userId: t
      .text()
      .notNull()
      .references(() => user.id, { onDelete: "cascade" }),
    role: t
      .text({ enum: [...UserRole] })
      .notNull()
      .default("member"),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.userId, t.organizationId)],
);
export const organizationUserMembershipRelations = relations(
  organizationUserMembership,
  ({ one }) => ({
    organization: one(organization, {
      fields: [organizationUserMembership.organizationId],
      references: [organization.id],
    }),
    user: one(user, {
      fields: [organizationUserMembership.userId],
      references: [user.id],
    }),
  }),
);

export const agentInstance = pgTable(
  "agent_instance",
  (t) => ({
    id: iterateId("agnt"),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    className: t.text().notNull(), // e.g. "IterateAgent" | "SlackAgent" | "OnboardingAgent"
    durableObjectName: t.text().notNull(),
    durableObjectId: t.text().notNull(),
    metadata: jsonb().$type<Record<string, unknown>>().default({}).notNull(),
    ...withTimestamps,
  }),
  (t) => [
    // Ensure names are unique per estate while allowing duplicates across estates
    uniqueIndex().on(t.estateId, t.durableObjectName),
    uniqueIndex().on(t.durableObjectId),
    // Listing helpers
    index().on(t.estateId),
    index().on(t.className),
  ],
);

export const agentInstanceRelations = relations(agentInstance, ({ one, many }) => ({
  estate: one(estate, {
    fields: [agentInstance.estateId],
    references: [estate.id],
  }),
  routes: many(agentInstanceRoute),
}));

export const agentInstanceRoute = pgTable(
  "agent_instance_route",
  (t) => ({
    id: iterateId("ador"),
    routingKey: t.text().notNull(), // e.g. "slack:{threadTs}"
    agentInstanceId: t
      .text()
      .notNull()
      .references(() => agentInstance.id, { onDelete: "cascade" }), // This is actually the `id` column
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.routingKey, t.agentInstanceId)],
);

export const agentInstanceRouteRelations = relations(agentInstanceRoute, ({ one }) => ({
  agentInstance: one(agentInstance, {
    fields: [agentInstanceRoute.agentInstanceId],
    references: [agentInstance.id],
  }),
}));

export const slackWebhookEvent = pgTable(
  "slack_webhook_event",
  (t) => ({
    id: iterateId("slackevent"),
    data: t.jsonb().$type<SlackEvent>().notNull(),
    ts: t.text("ts"),
    thread_ts: t.text("thread_ts"),
    channel: t.text("channel"),
    type: t.text("type"),
    subtype: t.text("subtype"),
    user: t.text("user"),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    ...withTimestamps,
  }),
  (table) => [
    // channel queries use all 4 of these columns, thread queries use the same except for channel
    index("channel_or_thread_messages").on(table.channel, table.ts, table.thread_ts, table.type),
    // Estate queries
    index().on(table.estateId),
  ],
);

export const slackWebhookEventRelations = relations(slackWebhookEvent, ({ one }) => ({
  estate: one(estate, {
    fields: [slackWebhookEvent.estateId],
    references: [estate.id],
  }),
}));

export const iterateConfig = pgTable(
  "iterate_config",
  (t) => ({
    id: iterateId("icfg"),
    config: t.jsonb().$type<{ contextRules?: any[] }>().notNull(),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    ...withTimestamps,
  }),
  (t) => [uniqueIndex().on(t.estateId)],
);

export const iterateConfigRelations = relations(iterateConfig, ({ one }) => ({
  estate: one(estate, {
    fields: [iterateConfig.estateId],
    references: [estate.id],
  }),
}));

export const builds = pgTable("builds", (t) => ({
  id: iterateId("build"),
  status: t.text({ enum: ["complete", "failed", "in_progress"] }).notNull(),
  commitHash: t.text().notNull(),
  commitMessage: t.text().notNull(),
  iterateWorkflowRunId: t.text(),
  webhookIterateId: t.text().notNull(),
  estateId: t
    .text()
    .notNull()
    .references(() => estate.id, { onDelete: "cascade" }),
  completedAt: t.timestamp(),
  output: t.jsonb().$type<{ stdout?: string; stderr?: string; exitCode?: number }>(),
  ...withTimestamps,
}));

export const buildsRelations = relations(builds, ({ one }) => ({
  estate: one(estate, {
    fields: [builds.estateId],
    references: [estate.id],
  }),
}));

export const mcpConnectionParam = pgTable(
  "mcp_connection_param",
  (t) => ({
    id: iterateId("mcp"),
    connectionKey: t.text().notNull(),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    paramKey: t.text().notNull(),
    paramValue: t.text().notNull(),
    paramType: t.text({ enum: ["header", "query_param"] }).notNull(),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.estateId, t.connectionKey, t.paramKey, t.paramType),
    index().on(t.estateId),
    index().on(t.connectionKey),
  ],
);

export const mcpConnectionParamRelations = relations(mcpConnectionParam, ({ one }) => ({
  estate: one(estate, {
    fields: [mcpConnectionParam.estateId],
    references: [estate.id],
  }),
}));

// Estate events (append-only, immutable)
export const estateOnboardingEvent = pgTable(
  "estate_onboarding_event",
  (t) => ({
    id: iterateId("onbe"),
    estateId: t
      .text()
      .notNull()
      .references(() => estate.id, { onDelete: "cascade" }),
    organizationId: t
      .text()
      .notNull()
      .references(() => organization.id, { onDelete: "cascade" }),
    eventType: t.text().notNull(),
    category: t.text({ enum: ["system", "user"] }).notNull(),
    detail: t.text(),
    metadata: jsonb().$type<Record<string, unknown>>().default({}).notNull(),
    ...withTimestamps,
  }),
  (t) => [
    uniqueIndex().on(t.estateId, t.eventType),
    index().on(t.estateId),
    index().on(t.estateId, t.category),
    index().on(t.category),
  ],
);

export const systemTasks = pgTable(
  "system_tasks",
  (t) => ({
    id: bigserial("id", { mode: "number" }).primaryKey(),
    aggregateType: t.text().notNull(),
    aggregateId: t.text().notNull(),
    taskType: t.text().notNull(),
    payload: jsonb().$type<Record<string, unknown>>().default({}),
    processedAt: t.timestamp(),
    attempts: t.integer().default(0).notNull(),
    error: t.text(),
    ...withTimestamps,
  }),
  (t) => [index().on(t.processedAt), index().on(t.aggregateType), index().on(t.aggregateId)],
);
