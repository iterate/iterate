#!/usr/bin/env tsx

import { writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import type { BillingMeter, BillingMetersConfig } from "../backend/billing/types.ts";
import { getAggregateKey, getMeterKey } from "../backend/billing/types.ts";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const billingDir = join(__dirname, "..", "backend", "billing");

// Popular models for billing. These are the most commonly used models on OpenRouter.
// Pricing is in USD per 1M tokens.
//
// To add more models in the future, you can:
// 1. Uncomment the models.dev fetch code below to pull all models dynamically
// 2. Or manually add models to the POPULAR_MODELS array
//
// For dynamic fetching from models.dev API:
// async function fetchModelsDevData() {
//   const response = await fetch("https://models.dev/api.json");
//   return response.json();
// }
// Then iterate over the providers and models to generate meters for all of them.

interface ModelDefinition {
  provider: string;
  model: string;
  name: string;
  inputPricePerMillion: number;
  outputPricePerMillion: number;
}

const POPULAR_MODELS: ModelDefinition[] = [
  // Anthropic
  {
    provider: "anthropic",
    model: "claude-sonnet-4-20250514",
    name: "Claude Sonnet 4",
    inputPricePerMillion: 3,
    outputPricePerMillion: 15,
  },
  {
    provider: "anthropic",
    model: "claude-3-5-sonnet-20241022",
    name: "Claude 3.5 Sonnet",
    inputPricePerMillion: 3,
    outputPricePerMillion: 15,
  },
  {
    provider: "anthropic",
    model: "claude-3-5-haiku-20241022",
    name: "Claude 3.5 Haiku",
    inputPricePerMillion: 0.8,
    outputPricePerMillion: 4,
  },

  // OpenAI
  {
    provider: "openai",
    model: "gpt-4o",
    name: "GPT-4o",
    inputPricePerMillion: 2.5,
    outputPricePerMillion: 10,
  },
  {
    provider: "openai",
    model: "gpt-4o-mini",
    name: "GPT-4o Mini",
    inputPricePerMillion: 0.15,
    outputPricePerMillion: 0.6,
  },
  {
    provider: "openai",
    model: "o1",
    name: "o1",
    inputPricePerMillion: 15,
    outputPricePerMillion: 60,
  },

  // Google
  {
    provider: "google",
    model: "gemini-2.5-pro",
    name: "Gemini 2.5 Pro",
    inputPricePerMillion: 1.25,
    outputPricePerMillion: 10,
  },
  {
    provider: "google",
    model: "gemini-2.5-flash",
    name: "Gemini 2.5 Flash",
    inputPricePerMillion: 0.15,
    outputPricePerMillion: 0.6,
  },
];

function generateMeters(): Record<string, BillingMeter> {
  const meters: Record<string, BillingMeter> = {};

  for (const model of POPULAR_MODELS) {
    const inputKey = getMeterKey("llm", model.provider, model.model, "input");
    meters[inputKey] = {
      key: inputKey,
      displayName: `${model.name} (Input)`,
      category: "llm",
      provider: model.provider,
      model: model.model,
      unit: "tokens",
      direction: "input",
      costPerUnit: model.inputPricePerMillion / 1_000_000,
      aggregateKey: getAggregateKey("llm", model.provider, "input"),
    };

    const outputKey = getMeterKey("llm", model.provider, model.model, "output");
    meters[outputKey] = {
      key: outputKey,
      displayName: `${model.name} (Output)`,
      category: "llm",
      provider: model.provider,
      model: model.model,
      unit: "tokens",
      direction: "output",
      costPerUnit: model.outputPricePerMillion / 1_000_000,
      aggregateKey: getAggregateKey("llm", model.provider, "output"),
    };
  }

  // Sandbox meters
  const sandboxProviders = [
    { provider: "daytona", displayName: "Daytona", costPerSecond: 0.0001 },
    { provider: "docker", displayName: "Docker", costPerSecond: 0 },
  ];

  for (const { provider, displayName, costPerSecond } of sandboxProviders) {
    const key = getMeterKey("sandbox", provider, undefined, "both");
    meters[key] = {
      key,
      displayName: `${displayName} Sandbox CPU`,
      category: "sandbox",
      provider,
      unit: "seconds",
      direction: "both",
      costPerUnit: costPerSecond,
      aggregateKey: getAggregateKey("sandbox", provider),
    };
  }

  return meters;
}

function generateTypeScriptFile(config: BillingMetersConfig): string {
  let output = `// This file is auto-generated by scripts/generate-billing-meters.ts
// Do not edit manually - run the script to update
// Generated at: ${config.generatedAt}
// Version: ${config.version}

import type { BillingMeter, BillingMetersConfig } from "./types.ts";

export const BILLING_METERS_CONFIG: BillingMetersConfig = {
  version: "${config.version}",
  generatedAt: "${config.generatedAt}",
  meters: {
`;

  const sortedKeys = Object.keys(config.meters).sort();
  for (const key of sortedKeys) {
    const meter = config.meters[key];
    output += `    "${key}": {\n`;
    output += `      key: "${meter.key}",\n`;
    output += `      displayName: "${meter.displayName}",\n`;
    output += `      category: "${meter.category}",\n`;
    output += `      provider: "${meter.provider}",\n`;
    if (meter.model) {
      output += `      model: "${meter.model}",\n`;
    }
    output += `      unit: "${meter.unit}",\n`;
    if (meter.direction) {
      output += `      direction: "${meter.direction}",\n`;
    }
    output += `      costPerUnit: ${meter.costPerUnit},\n`;
    if (meter.stripePriceId) {
      output += `      stripePriceId: "${meter.stripePriceId}",\n`;
    }
    if (meter.stripeProductId) {
      output += `      stripeProductId: "${meter.stripeProductId}",\n`;
    }
    output += `      aggregateKey: "${meter.aggregateKey}",\n`;
    output += `    } satisfies BillingMeter,\n`;
  }

  output += `  },
};

export const BILLING_METERS = BILLING_METERS_CONFIG.meters;

export function getMeter(key: string): BillingMeter | undefined {
  return BILLING_METERS[key];
}

export function getMetersByCategory(category: string): BillingMeter[] {
  return Object.values(BILLING_METERS).filter((m) => m.category === category);
}

export function getMetersByProvider(provider: string): BillingMeter[] {
  return Object.values(BILLING_METERS).filter((m) => m.provider === provider);
}

export function getMetersByAggregateKey(aggregateKey: string): BillingMeter[] {
  return Object.values(BILLING_METERS).filter((m) => m.aggregateKey === aggregateKey);
}
`;

  return output;
}

function main(): void {
  const meters = generateMeters();

  const config: BillingMetersConfig = {
    version: "1.0.0",
    generatedAt: new Date().toISOString(),
    meters,
  };

  const output = generateTypeScriptFile(config);
  const outputPath = join(billingDir, "meters.generated.ts");
  writeFileSync(outputPath, output);

  console.log(`Generated ${outputPath}`);
  console.log(`Total meters: ${Object.keys(meters).length}`);
}

main();
