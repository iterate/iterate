<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Egress Proxy</title>
    <style>
      :root {
        color-scheme: light;
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          sans-serif;
      }
      body {
        margin: 0;
        background: #f6f8fc;
        color: #0f172a;
      }
      main {
        max-width: 1100px;
        margin: 24px auto;
        padding: 0 16px 24px;
      }
      .panel {
        background: #fff;
        border: 1px solid #d8dfeb;
        border-radius: 12px;
        padding: 16px;
      }
      .panel + .panel {
        margin-top: 14px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 20px;
      }
      h2 {
        margin: 0 0 6px;
        font-size: 16px;
      }
      p {
        margin: 0;
        color: #334155;
        font-size: 14px;
      }
      code {
        background: #eef2ff;
        border: 1px solid #dbe3ff;
        border-radius: 6px;
        padding: 1px 4px;
        font-size: 13px;
      }
      .row {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: 10px;
        flex-wrap: wrap;
      }
      select,
      button,
      input {
        font: inherit;
        border: 1px solid #c6d2e2;
        border-radius: 8px;
        padding: 8px 10px;
        background: #eef4ff;
      }
      button {
        cursor: pointer;
        font-size: 13px;
      }
      button:hover {
        background: #dde8ff;
      }
      .btn-approve {
        background: #dcfce7;
        border-color: #86efac;
        color: #14532d;
      }
      .btn-approve:hover {
        background: #bbf7d0;
      }
      .btn-reject {
        background: #fee2e2;
        border-color: #fca5a5;
        color: #7f1d1d;
      }
      .btn-reject:hover {
        background: #fecaca;
      }
      .btn-save {
        background: #dbeafe;
        border-color: #93c5fd;
        color: #1e3a5f;
      }
      .btn-save:hover {
        background: #bfdbfe;
      }
      pre {
        margin: 12px 0 0;
        background: #0a1020;
        color: #dbe7ff;
        border-radius: 10px;
        padding: 12px;
        font-size: 12px;
        max-height: 60vh;
        overflow: auto;
        white-space: pre-wrap;
      }
      textarea {
        width: 100%;
        min-height: 200px;
        font-family: monospace;
        font-size: 12px;
        border: 1px solid #d8dfeb;
        border-radius: 8px;
        padding: 10px;
        box-sizing: border-box;
        margin-top: 8px;
        resize: vertical;
        tab-size: 2;
      }
      .approval-card {
        border: 1px solid #f7d7ac;
        background: #fff7ea;
        border-radius: 10px;
        padding: 12px;
        margin-top: 8px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
      }
      .approval-card .info {
        flex: 1;
        min-width: 0;
      }
      .approval-card .scope {
        font-size: 11px;
        text-transform: uppercase;
        color: #92400e;
        font-weight: 600;
      }
      .approval-card .summary {
        font-size: 13px;
        margin-top: 2px;
        word-break: break-all;
      }
      .approval-card .reason {
        font-size: 12px;
        color: #78716c;
        margin-top: 2px;
      }
      .approval-card .actions {
        display: flex;
        gap: 6px;
        flex-shrink: 0;
      }
      .empty {
        color: #94a3b8;
        font-size: 13px;
        padding: 8px 0;
      }
      .badge {
        display: inline-block;
        font-size: 11px;
        padding: 2px 8px;
        border-radius: 99px;
        font-weight: 600;
      }
      .badge-ok {
        background: #dcfce7;
        color: #14532d;
      }
      .badge-warn {
        background: #fef3c7;
        color: #92400e;
      }
      .secret-list {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .secret-key {
        font-size: 12px;
        background: #f1f5f9;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 2px 8px;
        font-family: monospace;
      }
      .sse-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 4px;
      }
      .sse-dot.connected {
        background: #22c55e;
      }
      .sse-dot.disconnected {
        background: #ef4444;
      }
      .policy-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 13px;
      }
      .policy-table th {
        text-align: left;
        padding: 4px 8px;
        border-bottom: 2px solid #e2e8f0;
        font-weight: 600;
      }
      .policy-table td {
        padding: 4px 8px;
        border-bottom: 1px solid #f1f5f9;
        font-family: monospace;
        font-size: 12px;
      }
      .save-msg {
        font-size: 12px;
        margin-left: 8px;
      }
      .save-msg.ok {
        color: #16a34a;
      }
      .save-msg.err {
        color: #dc2626;
      }
      details {
        margin-top: 10px;
      }
      details summary {
        cursor: pointer;
        font-size: 13px;
        color: #6366f1;
        font-weight: 500;
      }
      .tip {
        background: #fffbeb;
        border: 1px solid #fde68a;
        border-radius: 8px;
        padding: 10px;
        margin-top: 10px;
        font-size: 13px;
        color: #78350f;
      }
    </style>
  </head>
  <body>
    <main>
      <!-- Approvals -->
      <section class="panel" id="approvals-panel">
        <h1>Pending Approvals</h1>
        <p>
          Requests waiting for human decision.
          <span class="sse-dot disconnected" id="sse-dot"></span
          ><span id="sse-status">connecting...</span>
        </p>
        <div id="approvals-list">
          <div class="empty">No pending approvals</div>
        </div>
        <div class="tip">
          <strong>Test it:</strong> On the sandbox UI (<code>:38080</code>), click
          <code>Held example.com?review=1</code> then <code>Fetch</code>. An approval card will
          appear here. Click Approve or Reject. For WS: connect, then send a message containing
          <code>reviewme</code>.
        </div>
      </section>

      <!-- Cost Tracking -->
      <section class="panel" id="cost-panel">
        <h1>API Cost Tracking</h1>
        <p>
          Pricing from <a href="https://models.dev" target="_blank" rel="noopener">models.dev</a>.
          Tracks token usage from AI API responses.
        </p>
        <div class="row" style="margin-top: 8px">
          <span class="badge badge-ok" id="badge-models-loaded">models: ?</span>
          <span style="font-size: 24px; font-weight: 700; color: #0f172a" id="total-cost"
            >$0.000000</span
          >
          <span style="font-size: 13px; color: #64748b" id="total-tokens">0 tokens</span>
          <button onclick="resetCosts()" style="font-size: 12px; padding: 4px 8px">Reset</button>
        </div>
        <div id="cost-records" style="margin-top: 10px">
          <span class="empty"
            >No API calls tracked yet. Make an OpenAI/Anthropic request from the sandbox.</span
          >
        </div>
      </section>

      <!-- Status -->
      <section class="panel">
        <h1>System Status</h1>
        <div class="row" id="status-row">
          <span class="badge badge-ok" id="badge-secrets">secrets: ?</span>
          <span class="badge badge-ok" id="badge-policies">policies: ?</span>
          <span class="badge badge-warn" id="badge-approvals">pending: 0</span>
          <span class="badge badge-ok" id="badge-sse">sse clients: ?</span>
        </div>
      </section>

      <!-- Secrets -->
      <section class="panel">
        <h2>Loaded Secret Keys</h2>
        <p>Values are never exposed in the UI.</p>
        <div class="secret-list" id="secret-keys">
          <span class="empty">loading...</span>
        </div>
        <details id="secrets-editor">
          <summary>Edit secrets.json</summary>
          <textarea id="secrets-textarea" spellcheck="false" placeholder="Loading..."></textarea>
          <div class="row">
            <button class="btn-save" onclick="saveSecrets()">Save secrets.json</button>
            <span id="secrets-save-msg" class="save-msg"></span>
          </div>
        </details>
      </section>

      <!-- Policies -->
      <section class="panel">
        <h2>Active Policies</h2>
        <p>Evaluated in priority order (lowest = highest priority). Default deny if no match.</p>
        <div id="policies-container">
          <span class="empty">loading...</span>
        </div>
        <details id="policies-editor">
          <summary>Edit policies.json</summary>
          <textarea id="policies-textarea" spellcheck="false" placeholder="Loading..."></textarea>
          <div class="row">
            <button class="btn-save" onclick="savePolicies()">Save policies.json</button>
            <span id="policies-save-msg" class="save-msg"></span>
          </div>
        </details>
      </section>

      <!-- Log tail -->
      <section class="panel">
        <h1>Egress Proxy Log</h1>
        <p>
          Streamed via SSE (falls back to polling).
          <button id="clear-log" style="font-size: 12px; padding: 4px 8px">Clear</button>
        </p>
        <pre id="output">Connecting...</pre>
      </section>
    </main>

    <script>
      const output = document.getElementById("output");
      const approvalsEl = document.getElementById("approvals-list");
      const sseDot = document.getElementById("sse-dot");
      const sseStatusEl = document.getElementById("sse-status");
      const secretKeysEl = document.getElementById("secret-keys");
      const policiesContainer = document.getElementById("policies-container");
      const badgeSecrets = document.getElementById("badge-secrets");
      const badgePolicies = document.getElementById("badge-policies");
      const badgeApprovals = document.getElementById("badge-approvals");
      const badgeSSE = document.getElementById("badge-sse");
      const secretsTextarea = document.getElementById("secrets-textarea");
      const policiesTextarea = document.getElementById("policies-textarea");

      const totalCostEl = document.getElementById("total-cost");
      const totalTokensEl = document.getElementById("total-tokens");
      const costRecordsEl = document.getElementById("cost-records");
      const badgeModelsLoaded = document.getElementById("badge-models-loaded");

      const pendingApprovals = new Map();
      const costRecords = [];
      const logLines = [];
      const MAX_LOG_LINES = 500;
      let sseConnected = false;
      let runningCost = 0;
      let runningInputTokens = 0;
      let runningOutputTokens = 0;

      // --- SSE ---
      let evtSource = null;

      function connectSSE() {
        if (evtSource) {
          try {
            evtSource.close();
          } catch {}
        }
        evtSource = new EventSource("/api/events");

        evtSource.onopen = () => {
          sseConnected = true;
          sseDot.className = "sse-dot connected";
          sseStatusEl.textContent = "connected";
        };

        evtSource.onerror = () => {
          sseConnected = false;
          sseDot.className = "sse-dot disconnected";
          sseStatusEl.textContent = "reconnecting...";
        };

        evtSource.addEventListener("log", (e) => {
          try {
            const data = JSON.parse(e.data);
            appendLogLine(data.line);
          } catch {}
        });

        evtSource.addEventListener("approval:pending", (e) => {
          try {
            const data = JSON.parse(e.data);
            pendingApprovals.set(data.id, data);
            renderApprovals();
          } catch {}
        });

        evtSource.addEventListener("approval:decided", (e) => {
          try {
            const data = JSON.parse(e.data);
            pendingApprovals.delete(data.id);
            renderApprovals();
          } catch {}
        });

        evtSource.addEventListener("cost", (e) => {
          try {
            const record = JSON.parse(e.data);
            addCostRecord(record);
          } catch {}
        });
      }

      function appendLogLine(line) {
        logLines.push(line);
        if (logLines.length > MAX_LOG_LINES) logLines.splice(0, logLines.length - MAX_LOG_LINES);
        output.textContent = logLines.join("\n") + "\n";
        output.scrollTop = output.scrollHeight;
      }

      // --- Polling fallback ---
      // Polls approvals + log tail when SSE is disconnected
      async function pollFallback() {
        // Always poll approvals (they're critical for human-in-the-loop)
        await loadPendingApprovals();

        // Poll logs only if SSE is disconnected
        if (!sseConnected) {
          try {
            const res = await fetch(`/api/tail?lines=100&t=${Date.now()}`, { cache: "no-store" });
            const text = await res.text();
            const lines = text.split("\n").filter((l) => l.length > 0);
            // Only replace if we got new content
            if (lines.length > 0 && logLines.length === 0) {
              for (const line of lines) appendLogLine(line);
            }
          } catch {}
        }
      }

      function renderApprovals() {
        if (pendingApprovals.size === 0) {
          approvalsEl.innerHTML = '<div class="empty">No pending approvals</div>';
          badgeApprovals.textContent = "pending: 0";
          return;
        }

        badgeApprovals.textContent = `pending: ${pendingApprovals.size}`;
        let html = "";
        for (const [id, a] of pendingApprovals) {
          html += `
            <div class="approval-card" id="approval-${id}">
              <div class="info">
                <div class="scope">${a.scope || "http"}</div>
                <div class="summary">${escapeHtml(a.summary || a.url || a.method || id)}</div>
                ${a.reason ? `<div class="reason">${escapeHtml(a.reason)}</div>` : ""}
              </div>
              <div class="actions">
                <button class="btn-approve" onclick="approveRequest('${id}')">Approve</button>
                <button class="btn-reject" onclick="rejectRequest('${id}')">Reject</button>
              </div>
            </div>`;
        }
        approvalsEl.innerHTML = html;
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      async function approveRequest(id) {
        try {
          await fetch(`/api/approvals/${encodeURIComponent(id)}/approve`, { method: "POST" });
          pendingApprovals.delete(id);
          renderApprovals();
        } catch (err) {
          console.error("approve failed", err);
        }
      }

      async function rejectRequest(id) {
        try {
          await fetch(`/api/approvals/${encodeURIComponent(id)}/reject`, { method: "POST" });
          pendingApprovals.delete(id);
          renderApprovals();
        } catch (err) {
          console.error("reject failed", err);
        }
      }

      // --- Load data ---

      async function loadStatus() {
        try {
          const res = await fetch("/api/status");
          const data = await res.json();
          badgeSecrets.textContent = `secrets: ${data.secrets}`;
          badgePolicies.textContent = `policies: ${data.policies}`;
          badgeApprovals.textContent = `pending: ${data.pendingApprovals}`;
          badgeSSE.textContent = `sse clients: ${data.sseClients}`;
        } catch {}
      }

      async function loadSecrets() {
        try {
          const res = await fetch("/api/secrets");
          const data = await res.json();
          if (data.keys.length === 0) {
            secretKeysEl.innerHTML = '<span class="empty">No secrets loaded</span>';
          } else {
            secretKeysEl.innerHTML = data.keys
              .map((k) => `<span class="secret-key">${escapeHtml(k)}</span>`)
              .join("");
          }
        } catch {
          secretKeysEl.innerHTML = '<span class="empty">Failed to load</span>';
        }
      }

      async function loadSecretsRaw() {
        secretsTextarea.value =
          '{\n' +
          '  "secrets": [\n' +
          '    {\n' +
          '      "key": "openai.api_key",\n' +
          '      "value": "${OPENAI_API_KEY}",\n' +
          '      "egressRule": "url.hostname = \\'api.openai.com\\'"\n' +
          "    }\n" +
          "  ]\n" +
          "}";
      }

      async function loadPolicies() {
        try {
          const res = await fetch("/api/policies");
          const data = await res.json();
          if (data.policies.length === 0) {
            policiesContainer.innerHTML =
              '<span class="empty">No policies loaded (default deny all)</span>';
          } else {
            let html =
              '<table class="policy-table"><thead><tr><th>Pri</th><th>Expression</th><th>Decision</th><th>Reason</th></tr></thead><tbody>';
            for (const p of data.policies) {
              html += `<tr>
                <td>${p.priority}</td>
                <td>${escapeHtml(p.expression)}</td>
                <td>${escapeHtml(p.decision)}</td>
                <td>${escapeHtml(p.reason || "")}</td>
              </tr>`;
            }
            html += "</tbody></table>";
            policiesContainer.innerHTML = html;
          }
        } catch {
          policiesContainer.innerHTML = '<span class="empty">Failed to load</span>';
        }
      }

      async function loadPoliciesRaw() {
        try {
          const res = await fetch("/api/policies/raw");
          policiesTextarea.value = JSON.stringify(await res.json(), null, 2);
        } catch {
          policiesTextarea.value = '{\n  "policies": []\n}';
        }
      }

      async function loadPendingApprovals() {
        try {
          const res = await fetch("/api/approvals");
          const data = await res.json();
          const newIds = new Set(data.approvals.map((a) => a.id));
          // Merge: add new, remove gone
          for (const a of data.approvals) {
            if (!pendingApprovals.has(a.id)) pendingApprovals.set(a.id, a);
          }
          for (const id of pendingApprovals.keys()) {
            if (!newIds.has(id)) pendingApprovals.delete(id);
          }
          renderApprovals();
        } catch {}
      }

      // --- Save handlers ---

      function flashMsg(el, text, ok) {
        el.textContent = text;
        el.className = `save-msg ${ok ? "ok" : "err"}`;
        setTimeout(() => {
          el.textContent = "";
        }, 3000);
      }

      async function saveSecrets() {
        const msg = document.getElementById("secrets-save-msg");
        try {
          const body = JSON.parse(secretsTextarea.value);
          const res = await fetch("/api/secrets", {
            method: "PUT",
            headers: { "content-type": "application/json" },
            body: JSON.stringify(body),
          });
          const data = await res.json();
          if (res.ok) {
            flashMsg(msg, `Saved ${data.count} secrets`, true);
            loadSecrets();
            loadStatus();
          } else {
            flashMsg(msg, data.error || "Save failed", false);
          }
        } catch (err) {
          flashMsg(msg, `Invalid JSON: ${err.message}`, false);
        }
      }

      async function savePolicies() {
        const msg = document.getElementById("policies-save-msg");
        try {
          const body = JSON.parse(policiesTextarea.value);
          const res = await fetch("/api/policies", {
            method: "PUT",
            headers: { "content-type": "application/json" },
            body: JSON.stringify(body),
          });
          const data = await res.json();
          if (res.ok) {
            flashMsg(msg, `Saved ${data.count} policies`, true);
            loadPolicies();
            loadStatus();
          } else {
            flashMsg(msg, data.error || "Save failed", false);
          }
        } catch (err) {
          flashMsg(msg, `Invalid JSON: ${err.message}`, false);
        }
      }

      // --- Cost tracking ---
      function addCostRecord(record) {
        costRecords.unshift(record);
        if (costRecords.length > 50) costRecords.pop();
        runningCost += record.totalCost || 0;
        runningInputTokens += record.inputTokens || 0;
        runningOutputTokens += record.outputTokens || 0;
        renderCosts();
      }

      function renderCosts() {
        totalCostEl.textContent = `$${runningCost.toFixed(6)}`;
        totalTokensEl.textContent = `${(runningInputTokens + runningOutputTokens).toLocaleString()} tokens (${runningInputTokens.toLocaleString()} in / ${runningOutputTokens.toLocaleString()} out)`;

        if (costRecords.length === 0) {
          costRecordsEl.innerHTML = '<span class="empty">No API calls tracked yet.</span>';
          return;
        }

        let html =
          '<table class="policy-table"><thead><tr><th>Model</th><th>Input</th><th>Output</th><th>Cost</th><th>Time</th></tr></thead><tbody>';
        for (const r of costRecords) {
          const time = new Date(r.timestamp).toLocaleTimeString();
          html += `<tr>
            <td>${escapeHtml(r.model)}</td>
            <td>${(r.inputTokens || 0).toLocaleString()}</td>
            <td>${(r.outputTokens || 0).toLocaleString()}</td>
            <td>$${(r.totalCost || 0).toFixed(6)}</td>
            <td>${time}</td>
          </tr>`;
        }
        html += "</tbody></table>";
        costRecordsEl.innerHTML = html;
      }

      async function resetCosts() {
        try {
          await fetch("/api/costs/reset", { method: "POST" });
          costRecords.length = 0;
          runningCost = 0;
          runningInputTokens = 0;
          runningOutputTokens = 0;
          renderCosts();
        } catch {}
      }

      async function loadCosts() {
        try {
          const res = await fetch("/api/costs");
          const data = await res.json();
          runningCost = data.totalCost || 0;
          runningInputTokens = data.totalInputTokens || 0;
          runningOutputTokens = data.totalOutputTokens || 0;
          costRecords.length = 0;
          for (const r of (data.records || []).reverse()) costRecords.push(r);
          if (badgeModelsLoaded)
            badgeModelsLoaded.textContent = `models: ${data.modelsLoaded || 0}`;
          renderCosts();
        } catch {}
      }

      // --- Clear log ---
      document.getElementById("clear-log").addEventListener("click", () => {
        logLines.length = 0;
        output.textContent = "(cleared)\n";
      });

      // --- Init ---
      connectSSE();
      loadStatus();
      loadSecrets();
      loadSecretsRaw();
      loadPolicies();
      loadPoliciesRaw();
      loadPendingApprovals();
      loadCosts();

      // Poll approvals every 2s (critical for human-in-the-loop even with SSE)
      setInterval(pollFallback, 2000);

      // Refresh display data every 10s
      setInterval(() => {
        loadStatus();
        loadSecrets();
        loadPolicies();
      }, 10000);
    </script>
  </body>
</html>
